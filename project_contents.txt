=== app/Exceptions/Handler.php ===
<?php

namespace App\Exceptions;

use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Throwable;

class Handler extends ExceptionHandler
{
    /**
     * The list of the inputs that are never flashed to the session on validation exceptions.
     *
     * @var array<int, string>
     */
    protected $dontFlash = [
        'current_password',
        'password',
        'password_confirmation',
    ];

    /**
     * Register the exception handling callbacks for the application.
     */
    public function register(): void
    {
        $this->reportable(function (Throwable $e) {
            //
        });
    }
}


=== app/ValueObjects/ResourceConfig.php ===
<?php

namespace App\ValueObjects;

use App\Enums\SlotStrategy;
use InvalidArgumentException;

class ResourceConfig
{
    public ?bool $require_confirmation = false;
    public ?int $slot_duration_minutes = 60;
    public ?int $max_participants = null;
    public ?SlotStrategy $slot_strategy = SlotStrategy::FIXED;
    public ?int $min_advance_time = 0;
    public ?int $cancellation_time = null;
    public ?int $reschedule_time = null;
    public ?int $reminder_time = null;

    public function __construct(array $data = [])
    {
        foreach ($data as $key => $value) {
            if (property_exists($this, $key)) {
                $this->setProperty($key, $value);
            }
        }

        $this->validate();
    }

    private function setProperty(string $key, $value): void
    {
        if ($key === 'slot_strategy') {
            $this->slot_strategy = is_string($value) ? SlotStrategy::from($value) : $value;
        } else {
            $this->$key = $value;
        }
    }

    private function validate(): void
    {
        if ($this->slot_duration_minutes !== null && $this->slot_duration_minutes <= 0) {
            throw new InvalidArgumentException('Slot duration must be positive');
        }

        if ($this->max_participants !== null && $this->max_participants < 0) {
            throw new InvalidArgumentException('Max participants cannot be negative');
        }
    }

    public function toArray(): array
    {
        return [
            'require_confirmation' => $this->require_confirmation,
            'slot_duration_minutes' => $this->slot_duration_minutes,
            'max_participants' => $this->max_participants,
            'slot_strategy' => $this->slot_strategy->value,
            'min_advance_time' => $this->min_advance_time,
            'cancellation_time' => $this->cancellation_time,
            'reschedule_time' => $this->reschedule_time,
            'reminder_time' => $this->reminder_time,
        ];
    }

    public function isGroupResource(): bool
    {
        return $this->max_participants !== null && $this->max_participants > 1;
    }

    public function requiresConfirmation(): bool
    {
        return $this->require_confirmation === true;
    }

    public function isFixedStrategy(): bool
    {
        return $this->slot_strategy === SlotStrategy::FIXED;
    }

    public function isDynamicStrategy(): bool
    {
        return $this->slot_strategy === SlotStrategy::DYNAMIC;
    }

    public function canCancel(\DateTime $bookingStart): bool
    {
        if ($this->cancellation_time === null) return true;

        // –î–ª—è —Å—Ç—Ä–æ–≥–∏—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π: –µ—Å–ª–∏ cancellation_time = 0, –æ—Ç–º–µ–Ω–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞
        if ($this->cancellation_time === 0) {
            return false;
        }

        $now = new \DateTime();
        $diff = $now->diff($bookingStart);
        $minutes = $diff->days * 24 * 60 + $diff->h * 60 + $diff->i;

        return $minutes >= $this->cancellation_time;
    }

    public function canReschedule(\DateTime $bookingStart): bool
    {
        if ($this->reschedule_time === null) return true;

        // –î–ª—è —Å—Ç—Ä–æ–≥–∏—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π: –µ—Å–ª–∏ reschedule_time = 0, –ø–µ—Ä–µ–Ω–æ—Å –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω
        if ($this->reschedule_time === 0) {
            return false;
        }

        $now = new \DateTime();
        $diff = $now->diff($bookingStart);
        $minutes = $diff->days * 24 * 60 + $diff->h * 60 + $diff->i;

        return $minutes >= $this->reschedule_time;
    }

    public function shouldSendReminder(\DateTime $bookingStart): bool
    {
        if ($this->reminder_time === null) return false;

        $now = new \DateTime();
        $diff = $now->diff($bookingStart);
        $minutes = $diff->days * 24 * 60 + $diff->h * 60 + $diff->i;

        return $minutes <= $this->reminder_time;
    }
}


=== app/Services/Logging/BookingLoggerService.php ===
<?php

namespace App\Services\Logging;

use Illuminate\Support\Facades\Log;

class BookingLoggerService
{
    public static function info(string $message, array $context = []): void
    {
        Log::channel('booking')->info($message, $context);
    }

    public static function warning(string $message, array $context = []): void
    {
        Log::channel('booking')->warning($message, $context);
    }

    public static function error(string $message, array $context = []): void
    {
        Log::channel('booking')->error($message, $context);
    }

    public static function debug(string $message, array $context = []): void
    {
        Log::channel('booking')->debug($message, $context);
    }
}


=== app/Services/ArtisanCommandService.php ===
<?php

namespace App\Services;

use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Cache;

class ArtisanCommandService
{
    /**
     * –í—ã–ø–æ–ª–Ω—è–µ—Ç –∫–æ–º–∞–Ω–¥—É –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ
     */
    public function generateStaticTimetable(int $companyId): array
    {
        // –í—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–º–∞–Ω–¥—É
        Artisan::call('timetable:generate-static', [
            'company_id' => $companyId
        ]);

        // –ü–æ–ª—É—á–∞–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞
        $filePath = storage_path('app/exports/static_timetable_example.json');
        if (!file_exists($filePath)) {
            throw new \Exception('Static timetable example file not found');
        }

        $content = file_get_contents($filePath);
        return json_decode($content, true);
    }

    /**
     * –í—ã–ø–æ–ª–Ω—è–µ—Ç –∫–æ–º–∞–Ω–¥—É –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ
     */
    public function generateDynamicTimetable(int $companyId, int $days = 30): array
    {
        // –í—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–º–∞–Ω–¥—É
        Artisan::call('timetable:generate-dynamic', [
            'company_id' => $companyId,
            'days' => $days
        ]);

        // –ü–æ–ª—É—á–∞–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞
        $filePath = storage_path('app/exports/dynamic_timetable_example.json');
        if (!file_exists($filePath)) {
            throw new \Exception('Dynamic timetable example file not found');
        }

        $content = file_get_contents($filePath);
        return json_decode($content, true);
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏
     */
    public function getTimetableInfo(array $timetableData, string $type): array
    {
        if ($type === 'static') {
            $workingDays = count($timetableData['days'] ?? []);
            $totalBreaks = 0;

            foreach ($timetableData['days'] ?? [] as $day) {
                $totalBreaks += count($day['breaks'] ?? []);
            }

            return [
                'working_days' => $workingDays,
                'total_breaks' => $totalBreaks,
                'holidays' => count($timetableData['holidays'] ?? [])
            ];
        } else {
            $workingDays = count($timetableData['dates'] ?? []);
            $totalBreaks = 0;

            foreach ($timetableData['dates'] ?? [] as $date) {
                $totalBreaks += count($date['breaks'] ?? []);
            }

            return [
                'working_days' => $workingDays,
                'total_breaks' => $totalBreaks,
                'schedule_types' => array_unique(array_column($timetableData['dates'] ?? [], 'schedule_type'))
            ];
        }
    }
}


=== app/Services/Booking/BookingService.php ===
<?php
// app/Services/Booking/BookingService.php

namespace App\Services\Booking;

use App\Models\Booking;
use App\Models\Resource;
use App\Enums\BookingStatus;
use App\ValueObjects\ResourceConfig;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;
use App\Services\Logging\BookingLoggerService;

class BookingService
{
    public function __construct(
        private SlotGenerationService $slotService
    )
    {
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —Å —É—á–µ—Ç–æ–º –ø–µ—Ä–µ—Ä—ã–≤–æ–≤ –∏ –¥—Ä—É–≥–∏—Ö –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π
     */
    public function isTimeRangeAvailable(Resource $resource, Carbon $start, Carbon $end): bool
    {
        // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
        if (!$this->isRangeAvailable($resource, $start, $end)) {
            return false;
        }

        // –ó–∞—Ç–µ–º –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Ä—ã–≤—ã —Å –ò–°–ü–†–ê–í–õ–ï–ù–ù–û–ô –ª–æ–≥–∏–∫–æ–π
        if (!$this->isTimeAvailableConsideringBreaks($resource, $start, $end)) {
            return false;
        }

        return true;
    }

    public function isSlotAvailable(Resource $resource, string $start, int $slots = 1): bool
    {
        $startTime = Carbon::parse($start);
        $config = $resource->getResourceConfig();
        $duration = $config->slot_duration_minutes * $slots;
        $endTime = $startTime->copy()->addMinutes($duration);

        return $this->isRangeAvailable($resource, $startTime, $endTime);
    }

    // –í —Ñ–∞–π–ª–µ app/Services/Booking/BookingService.php

    public function isRangeAvailable(Resource $resource, Carbon $from, Carbon $to): bool
    {
        // todo: —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ?
        if ($from->greaterThanOrEqualTo($to)) {
            return false;
        }

        $overlapExists = Booking::query()
            ->where('resource_id', $resource->id)
            ->whereIn('status', [
                BookingStatus::PENDING->value,
                BookingStatus::CONFIRMED->value,
            ])
            ->where('start', '<', $to)
            ->where('end', '>', $from)
            ->exists();

        return !$overlapExists;

        $overlapExists = Booking::where('resource_id', $resource->id)
            ->where(function ($query) use ($from, $to) {
                $query->where(function ($q) use ($from, $to) {
                    // –ë—Ä–æ–Ω—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
                    $q->where('start', '>=', $from)
                        ->where('start', '<', $to);
                })->orWhere(function ($q) use ($from, $to) {
                    // –ë—Ä–æ–Ω—å –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
                    $q->where('end', '>', $from)
                        ->where('end', '<=', $to);
                })->orWhere(function ($q) use ($from, $to) {
                    // –ë—Ä–æ–Ω—å –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω
                    $q->where('start', '<', $from)
                        ->where('end', '>', $to);
                });
            })
            ->whereIn('status', [BookingStatus::PENDING->value, BookingStatus::CONFIRMED->value])
            ->exists();

        return !$overlapExists;
    }

    private function getBookingForThatPeriod(Resource $resource, Carbon $start, Carbon $end): ?Booking
    {
        return Booking::query()
            ->where('resource_id', $resource->id)
            ->where('start', '=', $start)
            ->where('end', '=', $end)
            ->first() ?? null;
    }

    /**
     * @throws \Throwable
     */
    public function createBooking(
        Resource      $resource,
        Carbon|string $start,
        Carbon|string $end,
        Model         $bookerData,
        bool          $isAdmin = false
    ): Booking
    {
        return DB::transaction(function () use ($resource, $start, $end, $bookerData, $isAdmin) {
            $config = $resource->getResourceConfig();
            $startTime = $start instanceof Carbon
                ? $start
                : Carbon::parse($start); // todo: –∑–¥–µ—Å—å –Ω–µ—É–∂–µ–Ω –∫–æ–Ω—Ç—Ä–æ–ª—å —á—Ç–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø—Ä–∏—Å—ã–ª–∞–µ—Ç –¥–∞—Ç—É –≤ –≤–∞–ª–∏–¥–Ω–æ–º —á–∞—Å–æ–≤–æ–º –ø–æ—è—Å–µ
            $endTime = $end instanceof Carbon
                ? $end
                : Carbon::parse($end); // todo: –∑–¥–µ—Å—å –Ω–µ—É–∂–µ–Ω –∫–æ–Ω—Ç—Ä–æ–ª—å —á—Ç–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø—Ä–∏—Å—ã–ª–∞–µ—Ç –¥–∞—Ç—É –≤ –≤–∞–ª–∏–¥–Ω–æ–º —á–∞—Å–æ–≤–æ–º –ø–æ—è—Å–µ

            $status = $config->requiresConfirmation() && !$isAdmin
                ? BookingStatus::PENDING
                : BookingStatus::CONFIRMED;

            if ($booking = $this->getBookingForThatPeriod($resource, $startTime, $endTime)) {
                if ($booking->status == BookingStatus::CONFIRMED->value || $booking->status == BookingStatus::PENDING->value) {
                    $this->attachBooker($booking, $bookerData, $isAdmin);
                }

                // todo: —Å–º todo –Ω–∏–∂–µ, –ø—Ä–æ–ø—É—â–µ–Ω return?
            }

            if (!$isAdmin) {
                $this->validateBookingTime($resource, $startTime, $endTime, $config);

                // –î–ª—è –æ–±—ã—á–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å
                if (!$this->isTimeRangeAvailable($resource, $startTime, $endTime)) {
                    throw new \Exception('–í—ã–±—Ä–∞–Ω–Ω—ã–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–∑–∞–Ω—è—Ç –∏–ª–∏ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è —Å –ø–µ—Ä–µ—Ä—ã–≤–æ–º)');
                }
            } else {
                // –î–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –±–∞–∑–æ–≤—É—é –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å –≤—Ä–µ–º–µ–Ω–∏
                if ($startTime >= $endTime) {
                    throw new \Exception('–í—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–æ—Å–ª–µ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞—á–∞–ª–∞');
                }

            }


            // todo: Booking —Å–æ–∑–¥–∞–µ—Ç—Å—è –¥–∞–∂–µ –µ—Å–ª–∏ –±—ã–ª attach? –ø–æ—á–µ–º—É?

            $booking = Booking::create([
                'company_id' => $resource->company_id,
                'resource_id' => $resource->id,
                'timetable_id' => $resource->getEffectiveTimetable()?->id, // todo –∑–∞—á–µ–º?
                'is_group_booking' => $config->isGroupResource(),
                'start' => $startTime,
                'end' => $endTime,
                'status' => $status->value,
            ]);

            if (!empty($bookerData)) {
                $this->attachBooker($booking, $bookerData);
            }

            BookingLoggerService::info("‚úÖ –ë—Ä–æ–Ω—å —Å–æ–∑–¥–∞–Ω–∞", [
                'booking_id' => $booking->id,
                'resource_id' => $resource->id,
                'status' => $booking->status,
                'is_admin' => $isAdmin
            ]);

            event(new \App\Events\BookingCreated($booking));

            return $booking;
        });
    }


    private function changeBookableStatus(Booking $booking, Model $booker, string $status, ?string $reason = ""): void
    {
        $booking->bookables()
            ->where('booking_id', '=', $booking->id)
            ->where('bookable_id', '=', $booker->id)
            ->where('bookable_type', '=', $booker::class)
            ->update(['status' => $status, 'reason' => $reason]);
        /**
         * –°—Ç–∞—Ä–∞—è –≤–µ—Ä—Å–∏—è. –ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ —Ç–µ—Å—Ç–∞–º–∏ –µ—â–µ.
         */
        DB::table('bookables')
            ->where('booking_id', '=', $booking->id)
            ->where('bookable_id', '=', $booker->id)
            ->where('bookable_type', '=', $booker::class)
            ->update(['status' => $status, 'reason' => $reason]);
    }

    public function confirmBooking(int $bookingId, Model $booker): Booking
    {
        $booking = Booking::findOrFail($bookingId);

        if ($booking->status !== BookingStatus::PENDING->value) {
            throw new \Exception('–ú–æ–∂–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞—Ç—å —Ç–æ–ª—å–∫–æ –±—Ä–æ–Ω–∏ –≤ —Å—Ç–∞—Ç—É—Å–µ –æ–∂–∏–¥–∞–Ω–∏—è');
        }

        $booking->status = BookingStatus::CONFIRMED->value;
        $booking->save();

        $this->changeBookableStatus($booking, $booker, BookingStatus::CONFIRMED->value);

        BookingLoggerService::info("‚úÖ –ë—Ä–æ–Ω—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞", ['booking_id' => $booking->id]);
        event(new \App\Events\BookingConfirmed($booking));

        return $booking;
    }

    public function cancelBooking(int $bookingId, string $cancelledBy = 'client', Model $booker, ?string $reason = null): Booking
    {
        $booking = Booking::findOrFail($bookingId);
        $config = $booking->resource->getResourceConfig();

        if ($cancelledBy === 'client' && !$config->canCancel($booking->start)) {
            throw new \Exception('–í—Ä–µ–º—è –¥–ª—è –æ—Ç–º–µ–Ω—ã –±—Ä–æ–Ω–∏ –∏—Å—Ç–µ–∫–ª–æ');
        }

        $status = $cancelledBy === 'admin'
            ? BookingStatus::CANCELLED_BY_ADMIN
            : BookingStatus::CANCELLED_BY_CLIENT;


        if (!$booking->is_group_booking) {
            $booking->update([
                'status' => $status->value,
                'reason' => $reason
            ]);
        }

        $this->changeBookableStatus($booking, $booker, $status->value, $reason);

        if ($booking->is_group_booking && !$booking->bookables()->where('status', '=', BookingStatus::CONFIRMED->value)->exists()) {
            $booking->update([
                'status' => $status->value,
                'reason' => $reason
            ]);
        }

        if (!$booking->is_group_booking) {
            BookingLoggerService::warning("‚ùå –ë—Ä–æ–Ω—å –æ—Ç–º–µ–Ω–µ–Ω–∞  –¥–ª—è {$booker->name} ", [
                'booking_id' => $booking->id,
                'cancelled_by' => $cancelledBy,
                'reason' => $reason
            ]);
        } else {
            BookingLoggerService::warning("‚ùå –ë—Ä–æ–Ω—å –æ—Ç–º–µ–Ω–µ–Ω–∞", [
                'booking_id' => $booking->id,
                'cancelled_by' => $cancelledBy,
                'reason' => $reason
            ]);
        }


        event(new \App\Events\BookingCancelled($booking));

        return $booking;
    }

    /**
     * @throws \Throwable
     */
    public function rescheduleBooking(
        int    $bookingId,
        string $newStart,
        string $newEnd,
        string $requestedBy = 'client'
    ): Booking
    {
        return DB::transaction(function () use ($bookingId, $newStart, $newEnd, $requestedBy) {
            $booking = Booking::findOrFail($bookingId);

            if ($booking->is_group_booking && $requestedBy == 'client') {
                throw new \Exception('–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –≥—Ä—É–ø–ø–æ–≤—É—é –±—Ä–æ–Ω—å –Ω–µ –∞–¥–º–∏–Ω—É');
            }

            if (BookingStatus::from($booking->status)->isCancelled()) {
                throw new \Exception('–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –æ—Ç–º–µ–Ω–µ–Ω–Ω—É—é –±—Ä–æ–Ω—å');
            }

            $resource = $booking->resource;
            $config = $resource->getResourceConfig();

            if ($requestedBy === 'client' && !$config->canReschedule($booking->start)) {
                throw new \Exception('–í—Ä–µ–º—è –¥–ª—è –ø–µ—Ä–µ–Ω–æ—Å–∞ –±—Ä–æ–Ω–∏ –∏—Å—Ç–µ–∫–ª–æ');
            }

            $newStartTime = Carbon::parse($newStart);
            $newEndTime = Carbon::parse($newEnd);

            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–æ–≤–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
            if ($requestedBy !== 'admin' && !$this->isTimeRangeAvailable($resource, $newStartTime, $newEndTime)) {
                throw new \Exception('–ù–æ–≤—ã–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–∑–∞–Ω—è—Ç –∏–ª–∏ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è —Å –ø–µ—Ä–µ—Ä—ã–≤–æ–º)');
            }

            $booking->update([
                'start' => $newStartTime,
                'end' => $newEndTime
            ]);

            BookingLoggerService::info("üîÅ –ë—Ä–æ–Ω—å –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–∞", [
                'booking_id' => $booking->id,
                'requested_by' => $requestedBy
            ]);

            event(new \App\Events\BookingRescheduled($booking));

            return $booking;
        });
    }

    public function getBookingsForResourceInRange(Resource $resource, string $from, string $to)
    {
        return Booking::where('resource_id', $resource->id)
            ->where('start', '<', $to)
            ->where('end', '>', $from)
            ->whereIn('status', [BookingStatus::PENDING->value, BookingStatus::CONFIRMED->value])
            ->get();
    }

    public function getNextAvailableSlots(
        Resource $resource,
        Carbon   $from = null,
        int      $count = 5,
        bool     $onlyToday = true
    ): array
    {
        return $this->slotService->getNextAvailableSlots($resource, $from, $count, $onlyToday);
    }

    // –í app/Services/Booking/BookingService.php
    private function validateBookingTime(Resource $resource, Carbon $start, Carbon $end, ResourceConfig $config): void
    {
        $now = now();

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
        if ($config->min_advance_time > 0) {
            $minutesUntilStart = $now->diffInMinutes($start, false); // false —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ—à–µ–¥—à–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏

            if ($minutesUntilStart < $config->min_advance_time) {
                throw new \Exception('–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –∑–∞ ' . $config->min_advance_time . ' –º–∏–Ω—É—Ç –¥–æ –Ω–∞—á–∞–ª–∞. –î–æ –Ω–∞—á–∞–ª–∞ –æ—Å—Ç–∞–ª–æ—Å—å: ' . $minutesUntilStart . ' –º–∏–Ω—É—Ç');
            }
        }

        // –î–ª—è —Å—Ç—Ä–æ–≥–∏—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π (min_advance_time = 0) - –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–ª—å–∫–æ –≤ –±—É–¥—É—â–µ–º
        if ($config->min_advance_time === 0 && $start <= $now) {
            throw new \Exception('–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –¥–ª—è –ø—Ä–æ—à–µ–¥—à–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏');
        }

        if ($start >= $end) {
            throw new \Exception('–í—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–æ–∑–∂–µ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞—á–∞–ª–∞');
        }

        if (!$this->isValidSlotTime($resource, $start, $end, $config)) {
            throw new \Exception('–í—ã–±—Ä–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã–º —Å–ª–æ—Ç–∞–º');
        }
    }

    private function isValidSlotTime(Resource $resource, Carbon $start, Carbon $end, ResourceConfig $config): bool
    {
        // todo: –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–ª–æ—Ç–æ–≤ –≤—Å–µ –µ—â—ë –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å —Å–ª–æ—Ç—ã "–æ—Ç –±–∞–ª–¥—ã", –æ–Ω–∞ –ø—Ä–æ—Å—Ç–æ –Ω–∞—Ä–µ–∑–∞–µ—Ç –∏—Ö –ø–æ –¥—Ä—É–≥–º—É –ø—Ä–∏–Ω—Ü–∏–ø—É
        if ($config->isFixedStrategy()) {
            $slots = $this->slotService->generateSlotsForDate($resource, $start);

            foreach ($slots as $slot) {
                if ($slot['start'] === $start->toDateTimeString() && $slot['end'] === $end->toDateTimeString()) {
                    return true;
                }
            }
            return false;
        }
        return true;
    }

    public function attachBooker(Booking $booking, Model $booker, ?bool $isAdmin = false): void
    {
        $config = $booking->resource->getResourceConfig();
        $countBookers = $booking->bookables()
            ->where('status', BookingStatus::CONFIRMED->value)
//            ->get()
            ->count();

        if ($countBookers < $config->max_participants ?? PHP_INT_MAX) {

             // todo: –Ω–µ–ø–æ–Ω—è—Ç–Ω–æ —á—Ç–æ —Ç—É—Ç –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç
            if ($isAdmin) {
                $booker->bookings()->syncWithoutDetaching([$booking->id => [
                    'status' => BookingStatus::CONFIRMED->value,
                    'reason' => $booking->reason,
                ]]);
                $booking->update([
                    'status' => BookingStatus::CONFIRMED->value,
                ]);
            } else {
                $booker->bookings()->syncWithoutDetaching([$booking->id => [
                    'status' => $booking->status,
                    'reason' => $booking->reason,
                ]]);
            }


        } else {
            // todo: business exception?

            $booker->bookings()->syncWithoutDetaching([$booking->id => [
                'status' => BookingStatus::REJECTED->value,
                'reason' => "–ë—Ä–æ–Ω—å –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∞",
            ]]);
        }

    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –≤—Ä–µ–º–µ–Ω–∏ —Å —É—á–µ—Ç–æ–º –ø–µ—Ä–µ—Ä—ã–≤–æ–≤
     */
    public function isTimeAvailableConsideringBreaks(Resource $resource, Carbon $start, Carbon $end): bool
    {
        $timetable = $resource->getEffectiveTimetable();


        if (!$timetable) {
            return true;
        }

        $workingHours = $this->getWorkingHoursForDate($timetable, $start);

        if (!$workingHours) {
            return true;
        }

        $breaks = $workingHours['breaks'] ?? [];

        foreach ($breaks as $break) {
            if (!isset($break['start']) || !isset($break['end'])) {
                continue;
            }

            try {
                $breakStart = Carbon::parse($start->format('Y-m-d') . ' ' . $break['start']);
                $breakEnd = Carbon::parse($start->format('Y-m-d') . ' ' . $break['end']);
            } catch (\Exception $e) {
                continue;
            }

            // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
            // –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –µ—Å—Ç—å –µ—Å–ª–∏:
            // - –Ω–∞—á–∞–ª–æ –±—Ä–æ–Ω–∏ –≤–Ω—É—Ç—Ä–∏ –ø–µ—Ä–µ—Ä—ã–≤–∞ (–∏—Å–∫–ª—é—á–∞—è –∫–æ–Ω–µ—Ü –ø–µ—Ä–µ—Ä—ã–≤–∞)
            // - –∫–æ–Ω–µ—Ü –±—Ä–æ–Ω–∏ –≤–Ω—É—Ç—Ä–∏ –ø–µ—Ä–µ—Ä—ã–≤–∞ (–∏—Å–∫–ª—é—á–∞—è –Ω–∞—á–∞–ª–æ –ø–µ—Ä–µ—Ä—ã–≤–∞)
            // - –±—Ä–æ–Ω—å –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–µ—Ä–µ—Ä—ã–≤
            // - –ø–µ—Ä–µ—Ä—ã–≤ –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–¥–µ—Ä–∂–∏—Ç –±—Ä–æ–Ω—å

            $startInBreak = $start->between($breakStart, $breakEnd, false);
            $endInBreak = $end->between($breakStart, $breakEnd, false);
            $spansBreak = $start->lt($breakStart) && $end->gt($breakEnd);
            $containedInBreak = $start->gte($breakStart) && $end->lte($breakEnd);

            // –î–û–ü–û–õ–ù–ï–ù–ò–ï: —Ä–∞–∑—Ä–µ—à–∞–µ–º –∫–∞—Å–∞–Ω–∏–µ –≥—Ä–∞–Ω–∏—Ü –ø–µ—Ä–µ—Ä—ã–≤–∞
            $touchesBreakStart = $end->eq($breakStart); // –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è —Ç–æ—á–Ω–æ –≤ –Ω–∞—á–∞–ª–µ –ø–µ—Ä–µ—Ä—ã–≤–∞ - –†–ê–ó–†–ï–®–ê–ï–ú
            $touchesBreakEnd = $start->eq($breakEnd);   // –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ç–æ—á–Ω–æ –≤ –∫–æ–Ω—Ü–µ –ø–µ—Ä–µ—Ä—ã–≤–∞ - –†–ê–ó–†–ï–®–ê–ï–ú

            if ($startInBreak || $endInBreak || $spansBreak || $containedInBreak) {
                return false;
            }

            // –ó–∞–ø—Ä–µ—â–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –±—Ä–æ–Ω—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –î–û –∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –ü–û–°–õ–ï –ø–µ—Ä–µ—Ä—ã–≤–∞
            // (–Ω–æ –Ω–µ –ø—Ä–æ—Å—Ç–æ –∫–∞—Å–∞–µ—Ç—Å—è –≥—Ä–∞–Ω–∏—Ü)
            if ($start->lt($breakStart) && $end->gt($breakEnd) &&
                !$touchesBreakStart && !$touchesBreakEnd) {
                return false;
            }
        }

        return true;
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç —Ä–∞–±–æ—á–∏–µ —á–∞—Å—ã –¥–ª—è –¥–∞—Ç—ã
     */
    private function getWorkingHoursForDate($timetable, Carbon $date): ?array
    {
        if (!$timetable || !isset($timetable->schedule)) {
            return null;
        }

        if ($timetable->type === 'static') {
            $dayOfWeek = strtolower($date->englishDayOfWeek);
            return $timetable->schedule['days'][$dayOfWeek] ?? null;
        } else {
            $dateKey = $date->format('m-d');
            return $timetable->schedule['dates'][$dateKey] ?? null;
        }
    }
}


=== app/Services/Booking/SlotGenerationService.php ===
<?php

namespace App\Services\Booking;

use App\Models\Resource;
use App\Models\Booking;
use App\ValueObjects\ResourceConfig;
use Carbon\Carbon;
use Carbon\CarbonPeriod;

class SlotGenerationService
{
    public function getNextAvailableSlots(
        Resource $resource,
        Carbon $from = null,
        int $count = 5,
        bool $onlyToday = true
    ): array {
        $from = $from ?? now();
        $config = $resource->getResourceConfig();
        $slots = [];
        $currentDate = $from->copy();

        while (count($slots) < $count) {
            $daySlots = $this->generateSlotsForDate($resource, $currentDate);

            // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –ø—É—Å—Ç—ã–µ —Å–ª–æ—Ç—ã –∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
            if (!empty($daySlots)) {
                foreach ($daySlots as $slot) {
                    if (count($slots) >= $count) break;

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Å–ª–æ—Ç –∏–º–µ–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
                    if (isset($slot['start']) && isset($slot['end'])) {
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Å–ª–æ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω
                        if ($this->isSlotAvailable($resource, $slot['start'], 1)) {
                            $slots[] = $slot;
                        }
                    }
                }
            }

            if ($onlyToday) break;
            $currentDate->addDay();
        }

        return $slots;
    }

    public function generateSlotsForDate(Resource $resource, Carbon $date): array
    {
        $config = $resource->getResourceConfig();
        $timetable = $resource->getEffectiveTimetable();

        if (!$timetable) {
            return [];
        }

        $workingHours = $this->getWorkingHoursForDate($timetable, $date);

        dump($workingHours);

        // –ï—Å–ª–∏ —Ä–∞–±–æ—á–∏–µ —á–∞—Å—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã (–ø—Ä–∞–∑–¥–Ω–∏–∫ –∏–ª–∏ –≤—ã—Ö–æ–¥–Ω–æ–π) - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤
        if (!$workingHours) {
            return [];
        }

        $slots = $config->isFixedStrategy()
            ? $this->generateFixedSlots($resource, $date, $workingHours, $config)
            : $this->generateDynamicSlots($resource, $date, $workingHours, $config);

        // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º —á—Ç–æ –≤—Å–µ —Å–ª–æ—Ç—ã –∏–º–µ—é—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
        return array_filter($slots, function($slot) {
            return isset($slot['start']) && isset($slot['end']) && isset($slot['duration_minutes']);
        });
    }

    private function generateFixedSlots(Resource $resource, Carbon $date, array $workingHours, ResourceConfig $config): array
    {
        if (!isset($workingHours['working_hours'])) {
            return [];
        }
        $breaks = $workingHours['breaks'] ?? [];
        $workingHours = $workingHours['working_hours'];
        $slots = [];
        $slotDuration = $config->slot_duration_minutes ?? 60;

        try {
            $startTime = Carbon::parse($date->format('Y-m-d') . ' ' . $workingHours['start']);
            $endTime = Carbon::parse($date->format('Y-m-d') . ' ' . $workingHours['end']);
        } catch (\Exception $e) {
            return [];
        }

        $current = $startTime->copy();

        while ($current->lt($endTime)) {
            $slotEnd = $current->copy()->addMinutes($slotDuration);

            if ($slotEnd->gt($endTime)) break;

            // –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê: –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ—Ä—ã–≤–æ–≤
            $slotAvailable = true;
            foreach ($breaks as $break) {
                if (!isset($break['start']) || !isset($break['end'])) continue;

                $breakStart = Carbon::parse($date->format('Y-m-d') . ' ' . $break['start']);
                $breakEnd = Carbon::parse($date->format('Y-m-d') . ' ' . $break['end']);

                // –°–ª–æ—Ç –Ω–µ –¥–æ–ª–∂–µ–Ω –ø–µ—Ä–µ—Å–µ–∫–∞—Ç—å—Å—è —Å –ø–µ—Ä–µ—Ä—ã–≤–æ–º
                if ($current->lt($breakEnd) && $slotEnd->gt($breakStart) &&
                    !$slotEnd->eq($breakStart) && !$current->eq($breakEnd)) {
                    $slotAvailable = false;
                    break;
                }
            }

            if ($slotAvailable) {
                $slots[] = [
                    'start' => $current->copy()->toDateTimeString(),
                    'end' => $slotEnd->copy()->toDateTimeString(),
                    'duration_minutes' => $slotDuration
                ];
                $current->addMinutes($slotDuration);
            } else {
                $current = $breakEnd->copy();
            }


        }

        return $slots;
    }

    private function generateDynamicSlots(Resource $resource, Carbon $date, array $workingHours, ResourceConfig $config): array
    {
        if (!isset($workingHours['working_hours'])) {
            return [];
        }

        $breaks = $workingHours['breaks'] ?? [];

        $workingHours = $workingHours['working_hours'];

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ working_hours –∏–º–µ–µ—Ç –Ω—É–∂–Ω—ã–µ –ø–æ–ª—è
        if (!isset($workingHours['start']) || !isset($workingHours['end'])) {
            return [];
        }

        $bookings = Booking::where('resource_id', $resource->id)
            ->whereDate('start', $date)
            ->whereIn('status', ['pending', 'confirmed'])
            ->orderBy('start')
            ->get();

        $slots = [];
        $slotDuration = $config->slot_duration_minutes ?? 60;

        try {
            $startTime = Carbon::parse($date->format('Y-m-d') . ' ' . $workingHours['start']);
            $endTime = Carbon::parse($date->format('Y-m-d') . ' ' . $workingHours['end']);
        } catch (\Exception $e) {
            return [];
        }

        $availablePeriods = $this->getAvailablePeriods($startTime, $endTime, $bookings, $breaks);

        foreach ($availablePeriods as $period) {
            $current = $period['start']->copy();

            while ($current->addMinutes($slotDuration)->lte($period['end'])) {
                $slotStart = $current->copy()->subMinutes($slotDuration);
                $slotEnd = $current->copy();

                $slots[] = [
                    'start' => $slotStart->toDateTimeString(),
                    'end' => $slotEnd->toDateTimeString(),
                    'duration_minutes' => $slotDuration
                ];
            }
        }

        return $slots;
    }

    private function getAvailablePeriods(Carbon $startTime, Carbon $endTime, $bookings, array $breaks): array
    {
        $periods = [['start' => $startTime, 'end' => $endTime]];

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
        foreach ($bookings as $booking) {
            $newPeriods = [];
            foreach ($periods as $period) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–µ—Ä–∏–æ–¥ –∏–º–µ–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
                if (!isset($period['start']) || !isset($period['end'])) {
                    continue;
                }

                if ($booking->start >= $period['end'] || $booking->end <= $period['start']) {
                    $newPeriods[] = $period;
                } else {
                    if ($booking->start > $period['start']) {
                        $newPeriods[] = ['start' => $period['start'], 'end' => $booking->start];
                    }
                    if ($booking->end < $period['end']) {
                        $newPeriods[] = ['start' => $booking->end, 'end' => $period['end']];
                    }
                }
            }
            $periods = $newPeriods;
        }

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–µ—Ä–µ—Ä—ã–≤—ã
        foreach ($breaks as $break) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–µ—Ä–µ—Ä—ã–≤ –∏–º–µ–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
            if (!isset($break['start']) || !isset($break['end'])) {
                continue;
            }

            try {
                $breakStart = Carbon::parse($startTime->format('Y-m-d') . ' ' . $break['start']);
                $breakEnd = Carbon::parse($startTime->format('Y-m-d') . ' ' . $break['end']);
            } catch (\Exception $e) {
                continue;
            }

            $newPeriods = [];
            foreach ($periods as $period) {
                if (!isset($period['start']) || !isset($period['end'])) {
                    continue;
                }

                if ($breakStart >= $period['end'] || $breakEnd <= $period['start']) {
                    $newPeriods[] = $period;
                } else {
                    if ($breakStart > $period['start']) {
                        $newPeriods[] = ['start' => $period['start'], 'end' => $breakStart];
                    }
                    if ($breakEnd < $period['end']) {
                        $newPeriods[] = ['start' => $breakEnd, 'end' => $period['end']];
                    }
                }
            }
            $periods = $newPeriods;
        }

        return $periods;
    }

    // –í app/Services/Booking/SlotGenerationService.php
    private function getWorkingHoursForDate($timetable, Carbon $date): ?array
    {
        if (!$timetable || !isset($timetable->schedule)) {
            return null;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–∑–¥–Ω–∏—á–Ω—ã–µ –¥–Ω–∏ –¥–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
        if ($timetable->type === 'static') {
            $dateKey = $date->format('m-d');
            $holidays = $timetable->schedule['holidays'] ?? [];

            // –ï—Å–ª–∏ –¥–∞—Ç–∞ –≤ –ø—Ä–∞–∑–¥–Ω–∏–∫–∞—Ö - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º null
            if (in_array($dateKey, $holidays)) {
                return null;
            }

            $dayOfWeek = strtolower($date->englishDayOfWeek);


            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ä–∞–±–æ—á–∏–µ —á–∞—Å—ã –¥–ª—è —ç—Ç–æ–≥–æ –¥–Ω—è –Ω–µ–¥–µ–ª–∏
            if (!isset($timetable->schedule['days'][$dayOfWeek])) {
                return null;
            }

            $daySchedule = $timetable->schedule['days'][$dayOfWeek];

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–µ–Ω—å –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ä–∞–±–æ—á–∏–π (–µ—Å—Ç—å —Ä–∞–±–æ—á–∏–µ —á–∞—Å—ã)
            if (!isset($daySchedule['working_hours']) ||
                !isset($daySchedule['working_hours']['start']) ||
                !isset($daySchedule['working_hours']['end']) ||
                empty($daySchedule['working_hours']['start']) ||
                empty($daySchedule['working_hours']['end'])) {
                return null;
            }

            return $daySchedule;
        } else {
            $dateKey = $date->format('m-d');
            return isset($timetable->schedule['dates'][$dateKey]) ? $timetable->schedule['dates'][$dateKey] : null;
        }
    }

    private function isTimeInBreaks(Carbon $start, Carbon $end, array $breaks): bool
    {
        foreach ($breaks as $break) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–µ—Ä–µ—Ä—ã–≤ –∏–º–µ–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
            if (!isset($break['start']) || !isset($break['end'])) {
                continue;
            }

            try {
                $breakStart = Carbon::parse($start->format('Y-m-d') . ' ' . $break['start']);
                $breakEnd = Carbon::parse($start->format('Y-m-d') . ' ' . $break['end']);
            } catch (\Exception $e) {
                continue;
            }

            if ($start < $breakEnd && $end > $breakStart) {
                return true;
            }
        }
        return false;
    }

    private function isSlotAvailable(Resource $resource, string $start, int $slots = 1): bool
    {
        try {
            $startTime = Carbon::parse($start);
        } catch (\Exception $e) {
            return false;
        }

        $config = $resource->getResourceConfig();
        $duration = ($config->slot_duration_minutes ?? 60) * $slots;
        $endTime = $startTime->copy()->addMinutes($duration);

        $overlapExists = Booking::where('resource_id', $resource->id)
            ->where('start', '<', $endTime)
            ->where('end', '>', $startTime)
            ->whereIn('status', ['pending', 'confirmed'])
            ->exists();

        return !$overlapExists;
    }
}


=== app/Models/Booking.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphToMany;

class Booking extends Model
{
    use HasFactory;

    protected $fillable = [
        'company_id',
        'resource_id',
        'timetable_id',
        'is_group_booking',
        'start',
        'end',
        'status',
        'reason'
    ];

    protected $casts = [
        'is_group_booking' => 'boolean',
        'start' => 'datetime',
        'end' => 'datetime'
    ];

    public function resource(): BelongsTo
    {
        return $this->belongsTo(Resource::class);
    }

    public function timetable(): BelongsTo
    {
        return $this->belongsTo(Timetable::class);
    }

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function users(): MorphToMany
    {
        return $this->morphToMany(
            User::class,
            'bookable',
            'bookables',
            'booking_id',
            'bookable_id'
        );
    }

    public function bookables(): HasMany
    {
        return $this->hasMany(Bookable::class);
    }
}


=== app/Models/Bookable.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\MorphTo;

class Bookable extends Model
{
    /**
     * –¢–∞–±–ª–∏—Ü–∞, —Å–≤—è–∑–∞–Ω–Ω–∞—è —Å –º–æ–¥–µ–ª—å—é.
     */
    protected $table = 'bookables';

    /**
     * –ê—Ç—Ä–∏–±—É—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–Ω–æ –º–∞—Å—Å–æ–≤–æ –Ω–∞–∑–Ω–∞—á–∞—Ç—å.
     */
    protected $fillable = [
        'booking_id',
        'reason',
        'status',
        'bookable_id',
        'bookable_type',
    ];

    /**
     * –ü–æ–ª—É—á–∏—Ç—å —Å–≤—è–∑–∞–Ω–Ω–æ–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ.
     */
    public function booking(): BelongsTo
    {
        return $this->belongsTo(Booking::class);
    }

    /**
     * –ü–æ–ª—É—á–∏—Ç—å —Å–≤—è–∑–∞–Ω–Ω—É—é –º–æ–¥–µ–ª—å (–º–æ—Ä—Ñ–∏—á–µ—Å–∫–æ–µ –æ—Ç–Ω–æ—à–µ–Ω–∏–µ).
     */
    public function bookable(): MorphTo
    {
        return $this->morphTo();
    }
}


=== app/Models/Company.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Company extends Model
{
    use HasFactory;

    public $incrementing = false; // –û—Ç–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ–∏–Ω–∫—Ä–µ–º–µ–Ω—Ç
    protected $keyType = 'integer'; // –¢–∏–ø –∫–ª—é—á–∞

    protected $fillable = ['id', 'name', 'description'];

    public function timetables(): HasMany
    {
        return $this->hasMany(Timetable::class);
    }

    public function resourceTypes(): HasMany
    {
        return $this->hasMany(ResourceType::class);
    }

    public function resources(): HasMany
    {
        return $this->hasMany(Resource::class);
    }

    public function bookings(): HasMany
    {
        return $this->hasMany(Booking::class);
    }
}


=== app/Models/Resource.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use App\Models\Concerns\HasResourceConfig;

class Resource extends Model
{
    use HasFactory, HasResourceConfig;

    protected $fillable = [
        'company_id',
        'timetable_id',
        'resource_type_id',
        'options',
        'payload',
        'resource_config',
    ];

    protected $casts = [
        'options' => 'array',
        'payload' => 'array',
        'resource_config' => 'array',
    ];

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function timetable(): BelongsTo
    {
        return $this->belongsTo(Timetable::class);
    }

    public function resourceType(): BelongsTo
    {
        return $this->belongsTo(ResourceType::class);
    }

    public function bookings()
    {
        return $this->hasMany(Booking::class);
    }
}


=== app/Models/ResourceType.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use App\Models\Concerns\HasResourceConfig;

class ResourceType extends Model
{
    use HasFactory, HasResourceConfig;

    protected $fillable = [
        'company_id',
        'timetable_id',
        'type',
        'name',
        'description',
        'options',
        'resource_config',
    ];

    protected $casts = [
        'options' => 'array',
        'resource_config' => 'array',
    ];

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function timetable(): BelongsTo
    {
        return $this->belongsTo(Timetable::class);
    }

    public function resources(): HasMany
    {
        return $this->hasMany(Resource::class);
    }
}


=== app/Models/Timetable.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Timetable extends Model
{
    use HasFactory;

    protected $fillable = [
        'company_id',
        'type',
        'schedule',
    ];

    protected $casts = [
        'schedule' => 'array',
    ];

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function resourceTypes(): HasMany
    {
        return $this->hasMany(ResourceType::class);
    }

    public function resources(): HasMany
    {
        return $this->hasMany(Resource::class);
    }

    public function bookings(): HasMany
    {
        return $this->hasMany(Booking::class);
    }
}


=== app/Models/User.php ===
<?php

namespace App\Models;

use App\Models\Concerns\HasBooking;
use Illuminate\Database\Eloquent\Factories\HasFactory;

use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;

class User extends Authenticatable
{
    use HasApiTokens, HasFactory, Notifiable, HasBooking;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
        'password' => 'hashed',
    ];

}


=== app/Models/Concerns/HasResourceConfig.php ===
<?php

namespace App\Models\Concerns;

use App\ValueObjects\ResourceConfig;
use Illuminate\Support\Arr;

trait HasResourceConfig
{
    public function getResourceConfig(): ResourceConfig
    {
        $config = $this->resource_config ?? [];

        if (method_exists($this, 'resourceType')) {
            $parentConfig = $this->resourceType->resource_config ?? [];
            $config = $this->mergeConfig($parentConfig, $config);
        }

        return new ResourceConfig($config);
    }

    public function getEffectiveTimetable()
    {
        if ($this->timetable_id) {
            return $this->timetable;
        }

        if (method_exists($this, 'resourceType') && $this->resourceType?->timetable_id) {
            return $this->resourceType->timetable;
        }

        return null;
    }

    private function isAssoc(array $array): bool
    {
        // PHP 8.1+ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ)
        if (function_exists('array_is_list')) {
            return !array_is_list($array);
        }

        // Fallback –¥–ª—è —Å—Ç–∞—Ä—ã—Ö PHP
        $i = 0;
        foreach (array_keys($array) as $k) {
            if ($k !== $i++) {
                return true;
            }
        }
        return false;
    }

    private function mergeConfig(array $base, array $overrides): array
    {
        foreach ($overrides as $key => $value) {
            if (
                array_key_exists($key, $base)
                && is_array($base[$key])
                && is_array($value)
                && $this->isAssoc($base[$key])
                && $this->isAssoc($value)
            ) {
                $base[$key] = $this->mergeConfig($base[$key], $value);
            } else {
                $base[$key] = $value;
            }
        }

        return $base;
    }
}


=== app/Models/Concerns/HasBooking.php ===
<?php

namespace App\Models\Concerns;

use App\Models\Booking;
use Illuminate\Database\Eloquent\Relations\MorphToMany;

trait HasBooking
{
    public function bookings(): MorphToMany
    {
        return $this->morphToMany(
            Booking::class,       // Related model
            'bookable',           // Name of the morph relation
            'bookables',          // Pivot table name
            'bookable_id',        // Foreign key for current model
            'booking_id'          // Foreign key for related model
        );
    }
}


=== app/Http/Kernel.php ===
<?php

namespace App\Http;

use Illuminate\Foundation\Http\Kernel as HttpKernel;

class Kernel extends HttpKernel
{
    /**
     * The application's global HTTP middleware stack.
     *
     * These middleware are run during every request to your application.
     *
     * @var array<int, class-string|string>
     */
    protected $middleware = [
        // \App\Http\Middleware\TrustHosts::class,
        \App\Http\Middleware\TrustProxies::class,
        \Illuminate\Http\Middleware\HandleCors::class,
        \App\Http\Middleware\PreventRequestsDuringMaintenance::class,
        \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,
        \App\Http\Middleware\TrimStrings::class,
        \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,
    ];

    /**
     * The application's route middleware groups.
     *
     * @var array<string, array<int, class-string|string>>
     */
    protected $middlewareGroups = [
        'web' => [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            \Illuminate\View\Middleware\ShareErrorsFromSession::class,
            \App\Http\Middleware\VerifyCsrfToken::class,
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
        ],

        'api' => [
            // \Laravel\Sanctum\Http\Middleware\EnsureFrontendRequestsAreStateful::class,
            \Illuminate\Routing\Middleware\ThrottleRequests::class.':api',
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
        ],
    ];

    /**
     * The application's middleware aliases.
     *
     * Aliases may be used instead of class names to conveniently assign middleware to routes and groups.
     *
     * @var array<string, class-string|string>
     */
    protected $middlewareAliases = [
        'auth' => \App\Http\Middleware\Authenticate::class,
        'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
        'auth.session' => \Illuminate\Session\Middleware\AuthenticateSession::class,
        'cache.headers' => \Illuminate\Http\Middleware\SetCacheHeaders::class,
        'can' => \Illuminate\Auth\Middleware\Authorize::class,
        'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
        'password.confirm' => \Illuminate\Auth\Middleware\RequirePassword::class,
        'precognitive' => \Illuminate\Foundation\Http\Middleware\HandlePrecognitiveRequests::class,
        'signed' => \App\Http\Middleware\ValidateSignature::class,
        'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
        'verified' => \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
    ];
}


=== app/Http/Controllers/TimetableController.php ===
<?php

namespace App\Http\Controllers;

use App\Actions\CreateOrUpdateCompanyAction;
use App\Actions\StoreTimetableAction;
use App\Actions\UpdateTimetableAction;
use App\Http\Requests\StoreTimetableRequest;
use App\Http\Requests\UpdateTimetableRequest;
use App\Http\Resources\TimetableResource;
use App\Models\Timetable;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;

class TimetableController extends Controller
{
    public function __construct(
        private CreateOrUpdateCompanyAction $createOrUpdateCompanyAction,
        private StoreTimetableAction $storeTimetableAction,
        private UpdateTimetableAction $updateTimetableAction
    ) {}

    public function index(): AnonymousResourceCollection
    {
        $timetables = Timetable::with(['company', 'resourceTypes', 'resources'])->get();
        return TimetableResource::collection($timetables);
    }

    public function store(StoreTimetableRequest $request): TimetableResource
    {
        $data = $request->validated();

        // –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –∫–æ–º–ø–∞–Ω–∏—é
        $this->createOrUpdateCompanyAction->execute($data['company_id']);

        $timetable = $this->storeTimetableAction->execute($data);

        return new TimetableResource($timetable->load(['company', 'resourceTypes', 'resources']));
    }

    public function show(Timetable $timetable): TimetableResource
    {
        return new TimetableResource($timetable->load(['company', 'resourceTypes', 'resources']));
    }

    public function update(UpdateTimetableRequest $request, Timetable $timetable): TimetableResource
    {
        $data = $request->validated();

        $timetable = $this->updateTimetableAction->execute($timetable, $data);

        return new TimetableResource($timetable->load(['company', 'resourceTypes', 'resources']));
    }

    public function destroy(Timetable $timetable): JsonResponse
    {
        $timetable->delete();
        return response()->json(['message' => 'Timetable deleted successfully']);
    }

    public function attachResource(Timetable $timetable, Request $request): JsonResponse
    {
        $request->validate([
            'resource_id' => 'required|exists:resources,id'
        ]);

        $resource = \App\Models\Resource::find($request->resource_id);
        $resource->update(['timetable_id' => $timetable->id]);

        return response()->json(['message' => 'Resource attached to timetable successfully']);
    }

    public function detachResource(Timetable $timetable, Request $request): JsonResponse
    {
        $request->validate([
            'resource_id' => 'required|exists:resources,id'
        ]);

        $resource = \App\Models\Resource::find($request->resource_id);
        if ($resource->timetable_id === $timetable->id) {
            $resource->update(['timetable_id' => null]);
        }

        return response()->json(['message' => 'Resource detached from timetable successfully']);
    }

    public function attachResourceType(Timetable $timetable, Request $request): JsonResponse
    {
        $request->validate([
            'resource_type_id' => 'required|exists:resource_types,id'
        ]);

        $resourceType = \App\Models\ResourceType::find($request->resource_type_id);
        $resourceType->update(['timetable_id' => $timetable->id]);

        return response()->json(['message' => 'Resource type attached to timetable successfully']);
    }

    public function detachResourceType(Timetable $timetable, Request $request): JsonResponse
    {
        $request->validate([
            'resource_type_id' => 'required|exists:resource_types,id'
        ]);

        $resourceType = \App\Models\ResourceType::find($request->resource_type_id);
        if ($resourceType->timetable_id === $timetable->id) {
            $resourceType->update(['timetable_id' => null]);
        }

        return response()->json(['message' => 'Resource type detached from timetable successfully']);
    }
}


=== app/Http/Controllers/Controller.php ===
<?php

namespace App\Http\Controllers;

use Illuminate\Foundation\Auth\Access\AuthorizesRequests;
use Illuminate\Foundation\Validation\ValidatesRequests;
use Illuminate\Routing\Controller as BaseController;

class Controller extends BaseController
{
    use AuthorizesRequests, ValidatesRequests;
}


=== app/Http/Controllers/Api/BookingController.php ===
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Http\Requests\CheckAvailabilityRequest;
use App\Http\Requests\GetResourceBookingsRequest;
use App\Models\Resource;
use App\Services\Booking\BookingService;
use App\Services\Booking\SlotGenerationService;
use App\Actions\RescheduleBookingAction;
use App\Http\Requests\CreateBookingRequest;
use App\Http\Requests\RescheduleBookingRequest;
use App\Http\Requests\CancelBookingRequest;
use App\Http\Requests\GetSlotsRequest;
use App\Http\Resources\BookingResource;
use App\Http\Resources\ResourceResource;
use App\Http\Resources\SlotResource;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Http\JsonResponse;
use Carbon\Carbon;

class BookingController extends Controller
{
    public function __construct(
        private BookingService $bookingService,
        private SlotGenerationService $slotService,
        private RescheduleBookingAction $rescheduleBookingAction
    ) {}

    public function getResources(): JsonResponse
    {
        $resources = Resource::with(['company', 'resourceType', 'timetable'])->get();
        return response()->json(ResourceResource::collection($resources));
    }

    public function getAvailableSlots($resourceId, GetSlotsRequest $request): JsonResponse
    {
        $resource = Resource::findOrFail($resourceId);
        $date = $request->get('date', now()->toDateString());
        $count = $request->get('count', 10);
        $onlyToday = $request->get('only_today', true);

        $from = Carbon::parse($date);
        $slots = $this->bookingService->getNextAvailableSlots($resource, $from, $count, $onlyToday);

        return response()->json(SlotResource::collection($slots));
    }

    public function createBooking(CreateBookingRequest $request): JsonResponse
    {
        try {
            $resource = Resource::findOrFail($request->resource_id);

            $booking = $this->bookingService->createBooking(
                $resource,
                $request->start,
                $request->end,
                $request->booker ?? [],
                $request->is_admin ?? false
            );

            return response()->json([
                'data' => new BookingResource($booking),
                'message' => $booking->status === 'pending'
                    ? '–ë—Ä–æ–Ω—å —Å–æ–∑–¥–∞–Ω–∞ –∏ –æ–∂–∏–¥–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è'
                    : '–ë—Ä–æ–Ω—å —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞ –∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞'
            ], 201);

        } catch (\Exception $e) {
            return response()->json([
                'error' => $e->getMessage()
            ], 422);
        }
    }

    public function confirmBooking(int $id, Model $booker): JsonResponse
    {
        try {
            $booking = $this->bookingService->confirmBooking($id, $booker);

            return response()->json([
                'data' => new BookingResource($booking),
                'message' => '–ë—Ä–æ–Ω—å —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞'
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => $e->getMessage()
            ], 422);
        }
    }

    public function cancelBooking($id, CancelBookingRequest $request): JsonResponse
    {
        try {
            $booking = $this->bookingService->cancelBooking(
                $id,
                $request->cancelled_by ?? 'client',
                $request->booker,
                $request->reason
            );

            return response()->json([
                'data' => new BookingResource($booking),
                'message' => '–ë—Ä–æ–Ω—å —É—Å–ø–µ—à–Ω–æ –æ—Ç–º–µ–Ω–µ–Ω–∞'
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => $e->getMessage()
            ], 422);
        }
    }

    public function rescheduleBooking($id, RescheduleBookingRequest $request): JsonResponse
    {
        try {
            $booking = $this->rescheduleBookingAction->execute(
                $id,
                $request->new_start,
                $request->new_end,
                $request->requested_by ?? 'client'
            );

            return response()->json([
                'data' => new BookingResource($booking),
                'message' => '–ë—Ä–æ–Ω—å —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–∞'
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => $e->getMessage()
            ], 422);
        }
    }

    public function getBookingsForResource($id, GetResourceBookingsRequest $request): JsonResponse
    {
        $resource = Resource::findOrFail($id);
        $bookings = $this->bookingService->getBookingsForResourceInRange(
            $resource,
            $request->from,
            $request->to
        );

        return response()->json(BookingResource::collection($bookings));
    }

    public function checkSlotAvailability(CheckAvailabilityRequest $request): JsonResponse
    {
        $resource = Resource::findOrFail($request->resource_id);

        if ($request->has('slots')) {
            $available = $this->bookingService->isSlotAvailable(
                $resource,
                $request->start,
                $request->slots
            );
        } else {
            $available = $this->bookingService->isRangeAvailable(
                $resource,
                Carbon::parse($request->start),
                Carbon::parse($request->end)
            );
        }

        return response()->json([
            'available' => $available,
            'message' => $available
                ? '–°–ª–æ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è'
                : '–°–ª–æ—Ç —É–∂–µ –∑–∞–Ω—è—Ç –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω'
        ]);
    }
}


=== app/Http/Controllers/Api/TimetableImportController.php ===
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Actions\CreateTimetableFromJsonAction;
use App\Http\Requests\ImportTimetableRequest;
use App\Http\Resources\TimetableResource;
use Illuminate\Http\JsonResponse;

class TimetableImportController extends Controller
{
    public function __construct(
        private CreateTimetableFromJsonAction $createTimetableFromJsonAction
    ) {}

    public function importFromJson(ImportTimetableRequest $request): JsonResponse
    {
        try {
            $timetable = $this->createTimetableFromJsonAction->execute(
                $request->company_id,
                $request->schedule_data,
                $request->type
            );

            return response()->json([
                'data' => new TimetableResource($timetable),
                'message' => 'Timetable imported successfully from JSON'
            ], 201);

        } catch (\Exception $e) {
            return response()->json([
                'error' => $e->getMessage()
            ], 422);
        }
    }

    public function importFromFile(ImportTimetableRequest $request): JsonResponse
    {
        try {
            $fileContent = file_get_contents($request->file('schedule_file')->getPathname());
            $scheduleData = json_decode($fileContent, true);

            if (json_last_error() !== JSON_ERROR_NONE) {
                throw new \Exception('Invalid JSON file: ' . json_last_error_msg());
            }

            $timetable = $this->createTimetableFromJsonAction->execute(
                $request->company_id,
                $scheduleData,
                $request->type
            );

            return response()->json([
                'data' => new TimetableResource($timetable),
                'message' => 'Timetable imported successfully from file'
            ], 201);

        } catch (\Exception $e) {
            return response()->json([
                'error' => $e->getMessage()
            ], 422);
        }
    }
}


=== app/Http/Controllers/CompanyController.php ===
<?php

namespace App\Http\Controllers;

use App\Http\Requests\StoreCompanyRequest;
use App\Http\Resources\CompanyResource;
use App\Models\Company;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;

class CompanyController extends Controller
{
    public function index(): AnonymousResourceCollection
    {
        $companies = Company::all();
        return CompanyResource::collection($companies);
    }

    public function store(StoreCompanyRequest $request): CompanyResource
    {
        $company = Company::create($request->validated());
        return new CompanyResource($company);
    }

    public function show(Company $company): CompanyResource
    {
        return new CompanyResource($company);
    }

    public function update(StoreCompanyRequest $request, Company $company): CompanyResource
    {
        $company->update($request->validated());
        return new CompanyResource($company);
    }

    public function destroy(Company $company): JsonResponse
    {
        $company->delete();
        return response()->json(['message' => 'Company deleted successfully']);
    }
}


=== app/Http/Controllers/ResourceController.php ===
<?php

namespace App\Http\Controllers;

use App\Actions\CreateOrUpdateCompanyAction;
use App\Actions\StoreResourceAction;
use App\Http\Requests\StoreResourceRequest;
use App\Http\Resources\ResourceResource;
use App\Models\Resource;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;

class ResourceController extends Controller
{
    public function __construct(
        private CreateOrUpdateCompanyAction $createOrUpdateCompanyAction,
        private StoreResourceAction $storeResourceAction
    ) {}

    public function index(): AnonymousResourceCollection
    {
        $resources = Resource::with(['company', 'timetable', 'resourceType'])->get();
        return ResourceResource::collection($resources);
    }

    public function store(StoreResourceRequest $request): ResourceResource
    {
        $data = $request->validated();

        // –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –∫–æ–º–ø–∞–Ω–∏—é –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω company_id
        if (isset($data['company_id'])) {
            $this->createOrUpdateCompanyAction->execute($data['company_id']);
        }

        $resource = $this->storeResourceAction->execute($data);

        return new ResourceResource($resource->load(['company', 'timetable', 'resourceType']));
    }

    public function show(Resource $resource): ResourceResource
    {
        return new ResourceResource($resource->load(['company', 'timetable', 'resourceType']));
    }

    public function update(StoreResourceRequest $request, Resource $resource): ResourceResource
    {
        $resource->update($request->validated());
        return new ResourceResource($resource->load(['company', 'timetable', 'resourceType']));
    }

    public function destroy(Resource $resource): JsonResponse
    {
        $resource->delete();
        return response()->json(['message' => 'Resource deleted successfully']);
    }
}


=== app/Http/Controllers/ResourceTypeController.php ===
<?php

namespace App\Http\Controllers;

use App\Actions\CreateOrUpdateCompanyAction;
use App\Actions\StoreResourceTypeAction;
use App\Http\Requests\StoreResourceTypeRequest;
use App\Http\Resources\ResourceTypeResource;
use App\Models\ResourceType;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;

class ResourceTypeController extends Controller
{
    public function __construct(
        private CreateOrUpdateCompanyAction $createOrUpdateCompanyAction,
        private StoreResourceTypeAction $storeResourceTypeAction
    ) {}

    public function index(): AnonymousResourceCollection
    {
        $resourceTypes = ResourceType::with(['company', 'timetable', 'resources'])->get();
        return ResourceTypeResource::collection($resourceTypes);
    }

    public function store(StoreResourceTypeRequest $request): ResourceTypeResource
    {
        $data = $request->validated();

        // –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –∫–æ–º–ø–∞–Ω–∏—é –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω company_id
        if (isset($data['company_id'])) {
            $this->createOrUpdateCompanyAction->execute($data['company_id']);
        }

        $resourceType = $this->storeResourceTypeAction->execute($data);

        return new ResourceTypeResource($resourceType->load(['company', 'timetable', 'resources']));
    }

    public function show(ResourceType $resourceType): ResourceTypeResource
    {
        return new ResourceTypeResource($resourceType->load(['company', 'timetable', 'resources']));
    }

    public function update(StoreResourceTypeRequest $request, ResourceType $resourceType): ResourceTypeResource
    {
        $resourceType->update($request->validated());
        return new ResourceTypeResource($resourceType->load(['company', 'timetable', 'resources']));
    }

    public function destroy(ResourceType $resourceType): JsonResponse
    {
        $resourceType->delete();
        return response()->json(['message' => 'Resource type deleted successfully']);
    }
}


=== app/Http/Requests/UpdateTimetableRequest.php ===
<?php

namespace App\Http\Requests;

use App\Enums\TimetableType;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

class UpdateTimetableRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'type' => ['sometimes', 'string', Rule::in(TimetableType::values())],
            'schedule' => 'sometimes|array',
            'schedule.days' => 'required_if:type,static|array',
            'schedule.days.*.working_hours' => 'required_if:type,static|array',
            'schedule.days.*.working_hours.start' => 'required_if:type,static|date_format:H:i',
            'schedule.days.*.working_hours.end' => 'required_if:type,static|date_format:H:i',
            'schedule.days.*.breaks' => 'sometimes|array',
            'schedule.days.*.breaks.*.start' => 'required_with:schedule.days.*.breaks|date_format:H:i',
            'schedule.days.*.breaks.*.end' => 'required_with:schedule.days.*.breaks|date_format:H:i',
            'schedule.holidays' => 'sometimes|array',
            'schedule.holidays.*' => 'string|regex:/^\d{2}-\d{2}$/',
            'schedule.dates' => 'required_if:type,dynamic|array',
            'schedule.dates.*.working_hours' => 'required_if:type,dynamic|array',
            'schedule.dates.*.working_hours.start' => 'required_if:type,dynamic|date_format:H:i',
            'schedule.dates.*.working_hours.end' => 'required_if:type,dynamic|date_format:H:i',
            'schedule.dates.*.breaks' => 'sometimes|array',
            'schedule.dates.*.breaks.*.start' => 'required_with:schedule.dates.*.breaks|date_format:H:i',
            'schedule.dates.*.breaks.*.end' => 'required_with:schedule.dates.*.breaks|date_format:H:i',
        ];
    }
}


=== app/Http/Requests/GetResourceBookingsRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class GetResourceBookingsRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'from' => 'required|date',
            'to' => 'required|date|after:from'
        ];
    }
}


=== app/Http/Requests/StoreTimetableRequest.php ===
<?php

namespace App\Http\Requests;

use App\Enums\TimetableType;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

class StoreTimetableRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'company_id' => 'required|integer|min:1',
            'type' => ['required', 'string', Rule::in(TimetableType::values())],
            'schedule' => 'required|array',
            'schedule.days' => 'required_if:type,static|array',
            'schedule.days.*.working_hours' => 'required_if:type,static|array',
            'schedule.days.*.working_hours.start' => 'required_if:type,static|date_format:H:i',
            'schedule.days.*.working_hours.end' => 'required_if:type,static|date_format:H:i',
            'schedule.days.*.breaks' => 'sometimes|array',
            'schedule.days.*.breaks.*.start' => 'required_with:schedule.days.*.breaks|date_format:H:i',
            'schedule.days.*.breaks.*.end' => 'required_with:schedule.days.*.breaks|date_format:H:i',
            'schedule.holidays' => 'sometimes|array',
            'schedule.holidays.*' => 'string|regex:/^\d{2}-\d{2}$/',
            'schedule.dates' => 'required_if:type,dynamic|array',
            'schedule.dates.*.working_hours' => 'required_if:type,dynamic|array',
            'schedule.dates.*.working_hours.start' => 'required_if:type,dynamic|date_format:H:i',
            'schedule.dates.*.working_hours.end' => 'required_if:type,dynamic|date_format:H:i',
            'schedule.dates.*.breaks' => 'sometimes|array',
            'schedule.dates.*.breaks.*.start' => 'required_with:schedule.dates.*.breaks|date_format:H:i',
            'schedule.dates.*.breaks.*.end' => 'required_with:schedule.dates.*.breaks|date_format:H:i',
        ];
    }

    public function messages(): array
    {
        return [
            'schedule.holidays.*.regex' => 'Holiday format must be MM-DD',
            'schedule.days.*.working_hours.start.date_format' => 'Start time must be in HH:MM format',
            'schedule.days.*.working_hours.end.date_format' => 'End time must be in HH:MM format',
            'schedule.dates.*.working_hours.start.date_format' => 'Start time must be in HH:MM format',
            'schedule.dates.*.working_hours.end.date_format' => 'End time must be in HH:MM format',
        ];
    }
}


=== app/Http/Requests/ImportTimetableRequest.php ===
<?php

namespace App\Http\Requests;

use App\Enums\TimetableType;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

class ImportTimetableRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'company_id' => 'required|integer|exists:companies,id',
            'type' => ['required', 'string', Rule::in(TimetableType::values())],
            'schedule_data' => 'required_without:schedule_file|array',
            'schedule_file' => 'required_without:schedule_data|file|mimes:json|max:10240',
        ];
    }

    public function messages(): array
    {
        return [
            'schedule_file.mimes' => 'The file must be a JSON file',
            'schedule_file.max' => 'The file size must not exceed 10MB',
        ];
    }
}


=== app/Http/Requests/CancelBookingRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class CancelBookingRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'cancelled_by' => 'sometimes|in:client,admin',
            'reason' => 'sometimes|string|max:255',
            'booker' => 'sometimes',
        ];
    }
}


=== app/Http/Requests/StoreCompanyRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreCompanyRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'name' => 'nullable|string|max:255',
            'description' => 'nullable|string',
        ];
    }
}


=== app/Http/Requests/GetSlotsRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class GetSlotsRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'date' => 'sometimes|date',
            'count' => 'sometimes|integer|min:1|max:50',
            'only_today' => 'sometimes|boolean'
        ];
    }
}


=== app/Http/Requests/CheckAvailabilityRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class CheckAvailabilityRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'resource_id' => 'required|exists:resources,id',
            'start' => 'required|date',
            'end' => 'required|date|after:start',
            'slots' => 'sometimes|integer|min:1'
        ];
    }
}


=== app/Http/Requests/StoreResourceTypeRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreResourceTypeRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'company_id' => 'sometimes|integer|min:1',
            'timetable_id' => 'nullable|integer|exists:timetables,id',
            'type' => 'required|string|max:63',
            'name' => 'required|string|max:127',
            'description' => 'nullable|string|max:255',
            'options' => 'nullable|array',
            'resource_config' => 'nullable|array',
        ];
    }
}


=== app/Http/Requests/CreateBookingRequest.php ===
<?php
// app/Http/Requests/CreateBookingRequest.php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class CreateBookingRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'resource_id' => 'required|exists:resources,id',
            'start' => 'required|date',
            'end' => 'required|date|after:start',
            'booker' => 'sometimes|array',
            'booker.external_id' => 'sometimes|string',
            'booker.type' => 'required|in:client,admin,employee',
            'booker.name' => 'sometimes|string',
            'booker.email' => 'sometimes|email',
            'booker.phone' => 'sometimes|string',
            'booker.metadata' => 'sometimes|array',
            'is_admin' => 'sometimes|boolean' // –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ —ç—Ç–æ –ø—Ä–∞–≤–∏–ª–æ –µ—Å—Ç—å
        ];
    }
}


=== app/Http/Requests/StoreResourceRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreResourceRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'company_id' => 'sometimes|integer|min:1',
            'timetable_id' => 'nullable|integer|exists:timetables,id',
            'resource_type_id' => 'required|integer|exists:resource_types,id',
            'options' => 'nullable|array',
            'payload' => 'nullable|array',
            'resource_config' => 'nullable|array',
        ];
    }
}


=== app/Http/Requests/RescheduleBookingRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class RescheduleBookingRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'new_start' => 'required|date',
            'new_end' => 'required|date|after:new_start',
            'requested_by' => 'sometimes|in:client,admin'
        ];
    }
}


=== app/Http/Resources/BookingResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class BookingResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'company_id' => $this->company_id,
            'resource_id' => $this->resource_id,
            'timetable_id' => $this->timetable_id,
            'is_group_booking' => $this->is_group_booking,
            'start' => $this->start,
            'end' => $this->end,
            'status' => $this->status,
            'reason' => $this->reason,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
            'resource' => new ResourceResource($this->whenLoaded('resource')),
            'company' => new CompanyResource($this->whenLoaded('company')),
            'timetable' => new TimetableResource($this->whenLoaded('timetable')),
            'bookers' => BookerResource::collection($this->whenLoaded('bookers')),
        ];
    }
}


=== app/Http/Resources/CompanyResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class CompanyResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'name' => $this->name,
            'description' => $this->description,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
        ];
    }
}


=== app/Http/Resources/BookerResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class BookerResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'external_id' => $this->external_id,
            'type' => $this->type,
            'name' => $this->name,
            'email' => $this->email,
            'phone' => $this->phone,
            'metadata' => $this->metadata,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
        ];
    }
}


=== app/Http/Resources/ResourceTypeResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class ResourceTypeResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'company_id' => $this->company_id,
            'timetable_id' => $this->timetable_id,
            'type' => $this->type,
            'name' => $this->name,
            'description' => $this->description,
            'options' => $this->options,
            'resource_config' => $this->resource_config,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
            'company' => new CompanyResource($this->whenLoaded('company')),
            'timetable' => new TimetableResource($this->whenLoaded('timetable')),
            'resources' => ResourceResource::collection($this->whenLoaded('resources')),
        ];
    }
}


=== app/Http/Resources/TimetableResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class TimetableResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'company_id' => $this->company_id,
            'type' => $this->type,
            'schedule' => $this->schedule,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
            'company' => new CompanyResource($this->whenLoaded('company')),
            'resource_types' => ResourceTypeResource::collection($this->whenLoaded('resourceTypes')),
            'resources' => ResourceResource::collection($this->whenLoaded('resources')),
        ];
    }
}


=== app/Http/Resources/SlotResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class SlotResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'start' => $this->resource['start'],
            'end' => $this->resource['end'],
            'duration_minutes' => $this->resource['duration_minutes'],
        ];
    }
}


=== app/Http/Resources/ResourceResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class ResourceResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'company_id' => $this->company_id,
            'timetable_id' => $this->timetable_id,
            'resource_type_id' => $this->resource_type_id,
            'options' => $this->options,
            'payload' => $this->payload,
            'resource_config' => $this->resource_config,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
            'company' => new CompanyResource($this->whenLoaded('company')),
            'timetable' => new TimetableResource($this->whenLoaded('timetable')),
            'resource_type' => new ResourceTypeResource($this->whenLoaded('resourceType')),
        ];
    }
}


=== app/Actions/StoreResourceTypeAction.php ===
<?php

namespace App\Actions;

use App\Models\ResourceType;

class StoreResourceTypeAction
{
    public function execute(array $data): ResourceType
    {
        // –ï—Å–ª–∏ company_id –Ω–µ —É–∫–∞–∑–∞–Ω, —Å–æ–∑–¥–∞–µ–º –∫–æ–º–ø–∞–Ω–∏—é
        if (!isset($data['company_id']) && isset($data['timetable_id'])) {
            // –ü–æ–ª—É—á–∞–µ–º company_id –∏–∑ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
            $timetable = \App\Models\Timetable::find($data['timetable_id']);
            if ($timetable) {
                $data['company_id'] = $timetable->company_id;
            }
        }

        return ResourceType::create($data);
    }
}


=== app/Actions/RescheduleBookingAction.php ===
<?php

namespace App\Actions;

use App\Models\Booking;
use App\Enums\BookingStatus;
use App\ValueObjects\ResourceConfig;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;

class RescheduleBookingAction
{
    public function execute(
        int $bookingId,
        string $newStart,
        string $newEnd,
        string $requestedBy = 'client'
    ): Booking {
        return DB::transaction(function () use ($bookingId, $newStart, $newEnd, $requestedBy) {
            $booking = Booking::findOrFail($bookingId);
            $resource = $booking->resource;
            $config = $resource->getResourceConfig();

            if (BookingStatus::from($booking->status)->isCancelled()) {
                throw new \Exception('–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –æ—Ç–º–µ–Ω–µ–Ω–Ω—É—é –±—Ä–æ–Ω—å');
            }

            if ($requestedBy === 'client' && !$config->canReschedule($booking->start)) {
                throw new \Exception('–í—Ä–µ–º—è –¥–ª—è –ø–µ—Ä–µ–Ω–æ—Å–∞ –±—Ä–æ–Ω–∏ –∏—Å—Ç–µ–∫–ª–æ');
            }

            $newStartTime = Carbon::parse($newStart);
            $newEndTime = Carbon::parse($newEnd);

            $booking->update([
                'start' => $newStartTime,
                'end' => $newEndTime
            ]);

            return $booking;
        });
    }
}


=== app/Actions/StoreTimetableAction.php ===
<?php

namespace App\Actions;

use App\Models\Timetable;
use Illuminate\Support\Facades\Storage;

class StoreTimetableAction
{
    public function execute(array $data): Timetable
    {
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
        $filename = 'timetable_' . time() . '.json';
        Storage::put('imports/' . $filename, json_encode($data['schedule']));

        $timetable = Timetable::create($data);

        return $timetable;
    }
}


=== app/Actions/UpdateTimetableAction.php ===
<?php

namespace App\Actions;

use App\Models\Timetable;
use Illuminate\Support\Facades\Storage;

class UpdateTimetableAction
{
    public function execute(Timetable $timetable, array $data): Timetable
    {
        if (isset($data['schedule'])) {
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Ñ–∞–π–ª —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
            $filename = 'timetable_' . $timetable->id . '_' . time() . '.json';
            Storage::put('imports/' . $filename, json_encode($data['schedule']));
        }

        $timetable->update($data);

        return $timetable;
    }
}


=== app/Actions/GenerateTestDataAction.php ===
<?php

namespace App\Actions;

use App\Models\Company;
use App\Models\Timetable;
use App\Models\ResourceType;
use App\Models\Resource;
use App\Models\Booking;
use App\Services\ArtisanCommandService;
use Carbon\Carbon;

class GenerateTestDataAction
{
    public function __construct(
        private CreateOrUpdateCompanyAction $createOrUpdateCompanyAction,
        private CreateTimetableFromJsonAction $createTimetableFromJsonAction,
        private ArtisanCommandService $artisanCommandService
    ) {}

    public function execute(int $companyId = 1): array
    {
        $company = $this->createOrUpdateCompanyAction->execute($companyId, 'Test Company ' . $companyId);

        // –°–æ–∑–¥–∞–µ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É—è Artisan –∫–æ–º–∞–Ω–¥—ã
        $staticTimetable = $this->createStaticTimetable($companyId);
        $dynamicTimetable = $this->createDynamicTimetable($companyId);

        // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
        $staticTimetableInfo = $this->artisanCommandService->getTimetableInfo($staticTimetable->schedule, 'static');
        $dynamicTimetableInfo = $this->artisanCommandService->getTimetableInfo($dynamicTimetable->schedule, 'dynamic');

        // –°–æ–∑–¥–∞–µ–º —Ç–∏–ø—ã —Ä–µ—Å—É—Ä—Å–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–Ω–∞–ª–∏–∑–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–π
        $resourceTypes = $this->createResourceTypes($companyId, $staticTimetable, $dynamicTimetable, $staticTimetableInfo, $dynamicTimetableInfo);

        // –°–æ–∑–¥–∞–µ–º —Ä–µ—Å—É—Ä—Å—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–∏–ø–æ–≤
        $resources = $this->createResources($companyId, $resourceTypes, $staticTimetable, $dynamicTimetable);

        // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
        $bookings = $this->createTestBookings($resources, $staticTimetable, $dynamicTimetable);

        return [
            'company' => $company,
            'timetables' => [
                'static' => $staticTimetable,
                'dynamic' => $dynamicTimetable
            ],
            'timetable_info' => [
                'static' => $staticTimetableInfo,
                'dynamic' => $dynamicTimetableInfo
            ],
            'resource_types' => $resourceTypes,
            'resources' => $resources,
            'bookings' => $bookings,
        ];
    }

    private function createStaticTimetable(int $companyId): Timetable
    {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º Artisan –∫–æ–º–∞–Ω–¥—É –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
        $staticData = $this->artisanCommandService->generateStaticTimetable($companyId);

        return $this->createTimetableFromJsonAction->execute($companyId, $staticData, 'static');
    }

    private function createDynamicTimetable(int $companyId): Timetable
    {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º Artisan –∫–æ–º–∞–Ω–¥—É –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
        $dynamicData = $this->artisanCommandService->generateDynamicTimetable($companyId, 14); // 14 –¥–Ω–µ–π –¥–ª—è —Ç–µ—Å—Ç–æ–≤

        return $this->createTimetableFromJsonAction->execute($companyId, $dynamicData, 'dynamic');
    }

    private function createResourceTypes(
        int $companyId,
        Timetable $staticTimetable,
        Timetable $dynamicTimetable,
        array $staticInfo,
        array $dynamicInfo
    ): array {
        // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö —Ç–∏–ø–æ–≤ —Ä–µ—Å—É—Ä—Å–æ–≤

        // –î–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è (—Ä–µ–≥—É–ª—è—Ä–Ω—ã–µ —Ä–∞–±–æ—á–∏–µ –¥–Ω–∏)
        $employeeType = ResourceType::create([
            'company_id' => $companyId,
            'timetable_id' => $staticTimetable->id,
            'type' => 'employee',
            'name' => '–°–æ—Ç—Ä—É–¥–Ω–∏–∫',
            'description' => "–ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–∏ ({$staticInfo['working_days']} —Ä–∞–±–æ—á–∏—Ö –¥–Ω–µ–π –≤ –Ω–µ–¥–µ–ª—é)",
            'resource_config' => [
                'slot_duration_minutes' => 60,
                'slot_strategy' => 'fixed',
                'require_confirmation' => false,
                'min_advance_time' => 60,
                'cancellation_time' => 120,
                'reschedule_time' => 240,
            ]
        ]);

        // –î–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è (–ø–µ—Ä–µ–≥–æ–≤–æ—Ä–Ω—ã–µ –∫–æ–º–Ω–∞—Ç—ã)
        $roomType = ResourceType::create([
            'company_id' => $companyId,
            'timetable_id' => $staticTimetable->id,
            'type' => 'meeting_room',
            'name' => '–ü–µ—Ä–µ–≥–æ–≤–æ—Ä–Ω–∞—è',
            'description' => "–ö–æ–º–Ω–∞—Ç–∞ –¥–ª—è –≤—Å—Ç—Ä–µ—á ({$staticInfo['total_breaks']} –ø–µ—Ä–µ—Ä—ã–≤–æ–≤ –≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏)",
            'resource_config' => [
                'slot_duration_minutes' => 30,
                'slot_strategy' => 'dynamic',
                'require_confirmation' => true,
                'max_participants' => 10,
                'min_advance_time' => 30,
            ]
        ]);

        // –î–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è (—Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è)
        $trainingType = ResourceType::create([
            'company_id' => $companyId,
            'timetable_id' => $dynamicTimetable->id,
            'type' => 'training',
            'name' => '–ì—Ä—É–ø–ø–æ–≤–∞—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞',
            'description' => "–ì—Ä—É–ø–ø–æ–≤—ã–µ –∑–∞–Ω—è—Ç–∏—è ({$dynamicInfo['working_days']} –¥–Ω–µ–π –≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏)",
            'resource_config' => [
                'slot_duration_minutes' => 90,
                'slot_strategy' => 'fixed',
                'require_confirmation' => false,
                'max_participants' => 20,
                'min_advance_time' => 1440,
            ]
        ]);

        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Ç–∏–ø –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è (—Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–µ –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ)
        $equipmentType = ResourceType::create([
            'company_id' => $companyId,
            'timetable_id' => $dynamicTimetable->id,
            'type' => 'equipment',
            'name' => '–°–ø–µ—Ü–∏–∞–ª—å–Ω–æ–µ –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ',
            'description' => '–û–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ –¥–ª—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π',
            'resource_config' => [
                'slot_duration_minutes' => 120,
                'slot_strategy' => 'dynamic',
                'require_confirmation' => true,
                'max_participants' => 5,
                'min_advance_time' => 480,
            ]
        ]);

        return [
            'employee' => $employeeType,
            'meeting_room' => $roomType,
            'training' => $trainingType,
            'equipment' => $equipmentType,
        ];
    }

    private function createResources(
        int $companyId,
        array $resourceTypes,
        Timetable $staticTimetable,
        Timetable $dynamicTimetable
    ): array {
        $resources = [];

        // –†–µ—Å—É—Ä—Å—ã –¥–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è (—Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∏)
        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['employee']->id,
            'timetable_id' => $staticTimetable->id,
            'options' => ['specialization' => '–ü–∞—Ä–∏–∫–º–∞—Ö–µ—Ä', 'experience' => '5 –ª–µ—Ç'],
            'resource_config' => ['slot_duration_minutes' => 45]
        ]);

        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['employee']->id,
            'timetable_id' => $staticTimetable->id,
            'options' => ['specialization' => '–ú–∞—Å—Å–∞–∂–∏—Å—Ç', 'experience' => '3 –≥–æ–¥–∞'],
        ]);

        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['employee']->id,
            'timetable_id' => $staticTimetable->id,
            'options' => ['specialization' => '–ö–æ—Å–º–µ—Ç–æ–ª–æ–≥', 'experience' => '4 –≥–æ–¥–∞'],
        ]);

        // –†–µ—Å—É—Ä—Å—ã –¥–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è (–ø–µ—Ä–µ–≥–æ–≤–æ—Ä–Ω—ã–µ)
        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['meeting_room']->id,
            'timetable_id' => $staticTimetable->id,
            'options' => ['location' => '–≠—Ç–∞–∂ 3', 'capacity' => 8, 'equipment' => ['projector', 'whiteboard']],
            'resource_config' => ['max_participants' => 8]
        ]);

        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['meeting_room']->id,
            'timetable_id' => $staticTimetable->id,
            'options' => ['location' => '–≠—Ç–∞–∂ 2', 'capacity' => 15, 'equipment' => ['tv', 'conference_phone']],
        ]);

        // –†–µ—Å—É—Ä—Å—ã –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è (—Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏)
        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['training']->id,
            'timetable_id' => $dynamicTimetable->id,
            'options' => ['location' => '–ó–∞–ª –ê', 'trainer' => '–ò–≤–∞–Ω –ü–µ—Ç—Ä–æ–≤', 'type' => '–ô–æ–≥–∞'],
        ]);

        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['training']->id,
            'timetable_id' => $dynamicTimetable->id,
            'options' => ['location' => '–ó–∞–ª –ë', 'trainer' => '–ú–∞—Ä–∏—è –°–∏–¥–æ—Ä–æ–≤–∞', 'type' => '–ü–∏–ª–∞—Ç–µ—Å'],
        ]);

        // –†–µ—Å—É—Ä—Å—ã –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è (–æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ)
        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['equipment']->id,
            'timetable_id' => $dynamicTimetable->id,
            'options' => ['name' => '3D –ø—Ä–∏–Ω—Ç–µ—Ä', 'model' => 'Ultimaker S5', 'specifications' => ['print_volume' => '330√ó240√ó300 mm']],
        ]);

        return $resources;
    }

    private function createTestBookings(array $resources, Timetable $staticTimetable, Timetable $dynamicTimetable): array
    {
        $bookings = [];
        $now = now();

        // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã—Ö –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π
        $staticSchedule = $staticTimetable->schedule;
        $dynamicSchedule = $dynamicTimetable->schedule;

        foreach ($resources as $resource) {
            $isStatic = $resource->timetable_id === $staticTimetable->id;
            $schedule = $isStatic ? $staticSchedule : $dynamicSchedule;

            // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—à–µ–¥—à–∏–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è (2-3 –Ω–∞ —Ä–µ—Å—É—Ä—Å)
            $pastBookingsCount = rand(2, 3);
            for ($i = 0; $i < $pastBookingsCount; $i++) {
                $daysAgo = rand(1, 7);
                $hour = rand(9, 16);

                $bookings[] = Booking::create([
                    'company_id' => 1,
                    'resource_id' => $resource->id,
                    'timetable_id' => $resource->timetable_id,
                    'start' => $now->copy()->subDays($daysAgo)->setHour($hour)->setMinute(0),
                    'end' => $now->copy()->subDays($daysAgo)->setHour($hour + 1)->setMinute(0),
                    'status' => 'confirmed',
                    'is_group_booking' => $resource->resourceType->type === 'training',
                ]);
            }

            // –°–æ–∑–¥–∞–µ–º –±—É–¥—É—â–∏–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è (1-2 –Ω–∞ —Ä–µ—Å—É—Ä—Å)
            $futureBookingsCount = rand(1, 2);
            for ($i = 0; $i < $futureBookingsCount; $i++) {
                $daysAhead = rand(1, 14);
                $hour = rand(9, 16);

                $bookings[] = Booking::create([
                    'company_id' => 1,
                    'resource_id' => $resource->id,
                    'timetable_id' => $resource->timetable_id,
                    'start' => $now->copy()->addDays($daysAhead)->setHour($hour)->setMinute(0),
                    'end' => $now->copy()->addDays($daysAhead)->setHour($hour + 1)->setMinute(0),
                    'status' => rand(0, 1) ? 'confirmed' : 'pending',
                    'is_group_booking' => $resource->resourceType->type === 'training',
                ]);
            }
        }

        return $bookings;
    }
}


=== app/Actions/StoreResourceAction.php ===
<?php

namespace App\Actions;

use App\Models\Resource;

class StoreResourceAction
{
    public function execute(array $data): Resource
    {
        // –ï—Å–ª–∏ company_id –Ω–µ —É–∫–∞–∑–∞–Ω, –±–µ—Ä–µ–º –∏–∑ —Ç–∏–ø–∞ —Ä–µ—Å—É—Ä—Å–∞
        if (!isset($data['company_id'])) {
            $resourceType = \App\Models\ResourceType::find($data['resource_type_id']);
            if ($resourceType) {
                $data['company_id'] = $resourceType->company_id;
            }
        }

        return Resource::create($data);
    }
}


=== app/Actions/CreateTimetableFromJsonAction.php ===
<?php

namespace App\Actions;

use App\Models\Timetable;
use App\Models\Company;
use App\Enums\TimetableType;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\ValidationException;

class CreateTimetableFromJsonAction
{
    public function execute(int $companyId, array $jsonData, string $type = 'static'): Timetable
    {
        // –û—á–∏—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ—Ç null –∑–Ω–∞—á–µ–Ω–∏–π
        $cleanedData = $this->cleanScheduleData($jsonData, $type);

        // –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
        $this->validateJsonData($cleanedData, $type);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫–æ–º–ø–∞–Ω–∏–∏
        $company = Company::find($companyId);
        if (!$company) {
            throw new \Exception("Company with ID {$companyId} not found");
        }

        // –°–æ–∑–¥–∞–µ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ
        return Timetable::create([
            'company_id' => $companyId,
            'type' => $type,
            'schedule' => $cleanedData,
        ]);
    }

    private function cleanScheduleData(array $data, string $type): array
    {
        if ($type === TimetableType::STATIC->value) {
            // –£–¥–∞–ª—è–µ–º –¥–Ω–∏ —Å null –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
            if (isset($data['days']) && is_array($data['days'])) {
                $data['days'] = array_filter($data['days'], function ($day) {
                    return $day !== null;
                });
            }
        } else {
            // –£–¥–∞–ª—è–µ–º –¥–∞—Ç—ã —Å null –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
            if (isset($data['dates']) && is_array($data['dates'])) {
                $data['dates'] = array_filter($data['dates'], function ($date) {
                    return $date !== null;
                });
            }
        }

        return $data;
    }

    private function validateJsonData(array $data, string $type): void
    {
        $rules = [];

        if ($type === TimetableType::STATIC->value) {
            $rules = [
                'days' => 'required|array',
                'days.*.working_hours' => 'required|array',
                'days.*.working_hours.start' => 'required|date_format:H:i',
                'days.*.working_hours.end' => 'required|date_format:H:i',
                'days.*.breaks' => 'sometimes|array',
                'days.*.breaks.*.start' => 'required_with:days.*.breaks|date_format:H:i',
                'days.*.breaks.*.end' => 'required_with:days.*.breaks|date_format:H:i',
                'holidays' => 'sometimes|array',
                'holidays.*' => 'string|regex:/^\d{2}-\d{2}$/',
            ];
        } else {
            $rules = [
                'dates' => 'required|array',
                'dates.*.working_hours' => 'required|array',
                'dates.*.working_hours.start' => 'required|date_format:H:i',
                'dates.*.working_hours.end' => 'required|date_format:H:i',
                'dates.*.breaks' => 'sometimes|array',
                'dates.*.breaks.*.start' => 'required_with:dates.*.breaks|date_format:H:i',
                'dates.*.breaks.*.end' => 'required_with:dates.*.breaks|date_format:H:i',
            ];
        }

        $validator = Validator::make($data, $rules);

        if ($validator->fails()) {
            throw new ValidationException($validator);
        }
    }
}


=== app/Actions/CreateOrUpdateCompanyAction.php ===
<?php

namespace App\Actions;

use App\Models\Company;

class CreateOrUpdateCompanyAction
{
    public function execute(int $companyId, ?string $name = null): Company
    {
        $company = Company::find($companyId);

        if (!$company) {
            $company = Company::create([
                'id' => $companyId,
                'name' => $name ?? '–ö–æ–º–ø–∞–Ω–∏—è_' . $companyId,
            ]);
        }

        return $company;
    }
}


=== app/Enums/TimetableType.php ===
<?php

namespace App\Enums;

enum TimetableType: string
{
    case STATIC = 'static';
    case DYNAMIC = 'dynamic';

    public static function values(): array
    {
        return array_column(self::cases(), 'value');
    }

    public static function isValid(string $value): bool
    {
        return in_array($value, self::values());
    }

    public function label(): string
    {
        return match($this) {
            self::STATIC => 'Static Schedule',
            self::DYNAMIC => 'dynamic Schedule',
        };
    }

    public function isStatic(): bool
    {
        return $this === self::STATIC;
    }

    public function isDynamic(): bool
    {
        return $this === self::DYNAMIC;
    }
}


=== app/Enums/BookingStatus.php ===
<?php

namespace App\Enums;

enum BookingStatus: string
{
    case PENDING = 'pending';
    case CONFIRMED = 'confirmed';
    case CANCELLED_BY_CLIENT = 'cancelled_by_client';
    case CANCELLED_BY_ADMIN = 'cancelled_by_admin';
    case REJECTED = 'rejected';

    public static function values(): array
    {
        return array_column(self::cases(), 'value');
    }

    public function label(): string
    {
        return match($this) {
            self::PENDING => '–û–∂–∏–¥–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è',
            self::CONFIRMED => '–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞',
            self::CANCELLED_BY_CLIENT => '–û—Ç–º–µ–Ω–µ–Ω–∞ –∫–ª–∏–µ–Ω—Ç–æ–º',
            self::CANCELLED_BY_ADMIN => '–û—Ç–º–µ–Ω–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º',
            self::REJECTED => '–û—Ç–∫–ª–æ–Ω–µ–Ω–∞',
        };
    }

    public function isActive(): bool
    {
        return in_array($this, [self::PENDING, self::CONFIRMED]);
    }

    public function isCancelled(): bool
    {
        return in_array($this, [self::CANCELLED_BY_CLIENT, self::CANCELLED_BY_ADMIN, self::REJECTED]);
    }
}


=== app/Enums/SlotStrategy.php ===
<?php

namespace App\Enums;

enum SlotStrategy: string
{
    case FIXED = 'fixed';
    case DYNAMIC = 'dynamic';

    public static function values(): array
    {
        return array_column(self::cases(), 'value');
    }

    public static function isValid(string $value): bool
    {
        return in_array($value, self::values());
    }

    public function label(): string
    {
        return match($this) {
            self::FIXED => 'fixed',
            self::DYNAMIC => 'dynamic',
        };
    }
}


=== database/seeders/DatabaseSeeder.php ===
<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        // \App\Models\User::factory(10)->create();

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}


=== database/.gitignore ===
*.sqlite*


=== database/factories/UserFactory.php ===
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\User>
 */
class UserFactory extends Factory
{
    /**
     * The current password being used by the factory.
     */
    protected static ?string $password;

    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            'name' => fake()->name(),
            'email' => fake()->unique()->safeEmail(),
            'email_verified_at' => now(),
            'password' => static::$password ??= Hash::make('password'),
            'remember_token' => Str::random(10),
        ];
    }

    /**
     * Indicate that the model's email address should be unverified.
     */
    public function unverified(): static
    {
        return $this->state(fn (array $attributes) => [
            'email_verified_at' => null,
        ]);
    }
}


=== database/migrations/2025_01_15_000003_create_resource_types_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('resource_types', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('company_id');
            $table->unsignedBigInteger('timetable_id')->nullable();
            $table->string('type', 63);
            $table->string('name', 127);
            $table->string('description', 255)->nullable();
            $table->json('options')->nullable();
            $table->json('resource_config')->nullable();
            $table->timestamps();
            $table->unique(['company_id', 'type']);

            $table->foreign('company_id')->references('id')->on('companies')->cascadeOnDelete();
            $table->foreign('timetable_id')->references('id')->on('timetables')->nullOnDelete();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('resource_types');
    }
};


=== database/migrations/2025_01_15_100000_create_booking_tables.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        // –¢–∞–±–ª–∏—Ü–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π
        Schema::create('bookings', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('company_id');
            $table->foreignId('resource_id')->constrained('resources')->cascadeOnDelete();
            $table->foreignId('timetable_id')->nullable()->constrained('timetables')->nullOnDelete();
            $table->boolean('is_group_booking')->default(false);
            $table->dateTime('start');
            $table->dateTime('end');
            $table->string('status')->default('pending');
            $table->string('reason', 255)->nullable();
            $table->timestamps();

            $table->foreign('company_id')->references('id')->on('companies')->cascadeOnDelete();
            $table->index(['resource_id', 'start', 'end']);
            $table->index(['company_id', 'start']);
        });

        // –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è morph-—Å–≤—è–∑–∏ (–∑–∞–º–µ–Ω—è–µ—Ç —Å—Ç–∞—Ä—ã–µ bookers –∏ booking_booker)
        Schema::create('bookables', function (Blueprint $table) {
            $table->id();
            $table->foreignId('booking_id')->constrained()->cascadeOnDelete();
            $table->string('status')->default('pending');
            $table->string('reason', 255)->nullable();
            $table->morphs('bookable'); // bookable_id, bookable_type
            $table->timestamps();

            $table->unique(['booking_id', 'bookable_id', 'bookable_type']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('bookables');
        Schema::dropIfExists('bookings');
    }
};


=== database/migrations/2014_10_12_100000_create_password_reset_tokens_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('password_reset_tokens', function (Blueprint $table) {
            $table->string('email')->primary();
            $table->string('token');
            $table->timestamp('created_at')->nullable();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('password_reset_tokens');
    }
};


=== database/migrations/2019_12_14_000001_create_personal_access_tokens_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('personal_access_tokens', function (Blueprint $table) {
            $table->id();
            $table->morphs('tokenable');
            $table->string('name');
            $table->string('token', 64)->unique();
            $table->text('abilities')->nullable();
            $table->timestamp('last_used_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('personal_access_tokens');
    }
};


=== database/migrations/2019_08_19_000000_create_failed_jobs_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('failed_jobs', function (Blueprint $table) {
            $table->id();
            $table->string('uuid')->unique();
            $table->text('connection');
            $table->text('queue');
            $table->longText('payload');
            $table->longText('exception');
            $table->timestamp('failed_at')->useCurrent();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('failed_jobs');
    }
};


=== database/migrations/2025_01_15_000002_create_timetables_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('timetables', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('company_id');
            $table->string('type', 32)->default('static');
            $table->json('schedule')->nullable();
            $table->timestamps();

            $table->foreign('company_id')->references('id')->on('companies')->cascadeOnDelete();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('timetables');
    }
};


=== database/migrations/2025_01_15_000004_create_resources_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('resources', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('company_id');
            $table->unsignedBigInteger('timetable_id')->nullable();
            $table->foreignId('resource_type_id')->constrained('resource_types')->cascadeOnDelete();
            $table->json('options')->nullable();
            $table->json('payload')->nullable();
            $table->json('resource_config')->nullable();
            $table->timestamps();

            $table->foreign('company_id')->references('id')->on('companies')->cascadeOnDelete();
            $table->foreign('timetable_id')->references('id')->on('timetables')->nullOnDelete();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('resources');
    }
};


=== database/migrations/2014_10_12_000000_create_users_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('users');
    }
};


=== database/migrations/2025_01_15_000001_create_companies_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('companies', function (Blueprint $table) {
            $table->unsignedBigInteger('id')->primary();
            $table->string('name')->nullable();
            $table->text('description')->nullable();
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('companies');
    }
};


=== routes/console.php ===
<?php

use Illuminate\Foundation\Inspiring;
use Illuminate\Support\Facades\Artisan;

/*
|--------------------------------------------------------------------------
| Console Routes
|--------------------------------------------------------------------------
|
| This file is where you may define all of your Closure based console
| commands. Each Closure is bound to a command instance allowing a
| simple approach to interacting with each command's IO methods.
|
*/

Artisan::command('inspire', function () {
    $this->comment(Inspiring::quote());
})->purpose('Display an inspiring quote');


=== routes/api.php ===
<?php

use Illuminate\Support\Facades\Route;

// =============================================
// Booking System Routes - Core Entities
// =============================================

use App\Http\Controllers\CompanyController;
use App\Http\Controllers\TimetableController;
use App\Http\Controllers\ResourceTypeController;
use App\Http\Controllers\ResourceController;
use App\Http\Controllers\Api\BookingController;
use App\Http\Controllers\Api\TimetableImportController;

// Core Entities CRUD
Route::apiResource('companies', CompanyController::class);
Route::apiResource('timetables', TimetableController::class);
Route::apiResource('resource-types', ResourceTypeController::class);
Route::apiResource('resources', ResourceController::class);

// Additional timetable routes
Route::prefix('timetables/{timetable}')->group(function () {
    Route::post('/attach-resource', [TimetableController::class, 'attachResource']);
    Route::post('/detach-resource', [TimetableController::class, 'detachResource']);
    Route::post('/attach-resource-type', [TimetableController::class, 'attachResourceType']);
    Route::post('/detach-resource-type', [TimetableController::class, 'detachResourceType']);
});

// =============================================
// Booking System Routes - Booking Functionality
// =============================================

Route::prefix('booking')->group(function () {
    Route::get('/resources', [BookingController::class, 'getResources']);
    Route::get('/{resource}/slots', [BookingController::class, 'getAvailableSlots']);
    Route::post('/create', [BookingController::class, 'createBooking']);
    Route::post('/{id}/confirm', [BookingController::class, 'confirmBooking']);
    Route::post('/{id}/cancel', [BookingController::class, 'cancelBooking']);
    Route::post('/{id}/reschedule', [BookingController::class, 'rescheduleBooking']);
    Route::get('/resource/{id}/bookings', [BookingController::class, 'getBookingsForResource']);
    Route::get('/check', [BookingController::class, 'checkSlotAvailability']);
});

// =============================================
// Timetable Import Routes
// =============================================

Route::prefix('timetables')->group(function () {
    Route::post('/import-json', [TimetableImportController::class, 'importFromJson']);
    Route::post('/import-file', [TimetableImportController::class, 'importFromFile']);
});



=== routes/channels.php ===
<?php

use Illuminate\Support\Facades\Broadcast;

/*
|--------------------------------------------------------------------------
| Broadcast Channels
|--------------------------------------------------------------------------
|
| Here you may register all of the event broadcasting channels that your
| application supports. The given channel authorization callbacks are
| used to check if an authenticated user can listen to the channel.
|
*/

Broadcast::channel('App.Models.User.{id}', function ($user, $id) {
    return (int) $user->id === (int) $id;
});


=== routes/web.php ===
<?php

use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| Web Routes
|--------------------------------------------------------------------------
|
| Here is where you can register web routes for your application. These
| routes are loaded by the RouteServiceProvider and all of them will
| be assigned to the "web" middleware group. Make something great!
|
*/

Route::get('/', function () {
    return view('welcome');
});

Route::get('/test', function () {


    $config = new \App\ValueObjects\ResourceConfig([
        "min_advance_time" => 60
    ]);

    $now = now(); // 18:14
    $start = \Carbon\Carbon::parse("2026-02-03 19:20:00 Europe/Moscow");



    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
    if ($config->min_advance_time > 0) {
        $minutesUntilStart = $now->diffInMinutes($start, false); // false —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ—à–µ–¥—à–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏

        if ($minutesUntilStart < $config->min_advance_time) {
            throw new \Exception('–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –∑–∞ ' . $config->min_advance_time . ' –º–∏–Ω—É—Ç –¥–æ –Ω–∞—á–∞–ª–∞. –î–æ –Ω–∞—á–∞–ª–∞ –æ—Å—Ç–∞–ª–æ—Å—å: ' . $minutesUntilStart . ' –º–∏–Ω—É—Ç');
        }
    }

    dd($minutesUntilStart ?? $config);

    /**
     * @var \App\Models\Resource $resource
     */
    $resource = \App\Models\Resource::first();
    /**
     * @var \App\Services\Booking\BookingService $bs
     * @var \App\Services\Booking\BookingService $bookingService
     */
    $bs = $bookingService = app(\App\Services\Booking\BookingService::class);

    $booker = \App\Models\User::first();

    $r = $bs->getNextAvailableSlots(
        $resource,
        now()->startOfDay(),
        1000
    );

    dd($r);
//
//    $booking = $bookingService->createBooking(
//        $resource,
//        now()->startOfDay()->addHours(10),
//        now()->startOfDay()->addHours(10)->addMinutes(15),
//        $booker,
//        true
//    );
//
//    dd($booking);

    dump($resource, $resource->getResourceConfig());

    dump($r[0] ?? null, $r[1] ?? null, $r[2] ?? null);
    dd($r);

});


