=== app/Http/Resources/CompanyResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class CompanyResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'name' => $this->name,
            'description' => $this->description,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
        ];
    }
}



=== app/Http/Resources/ResourceTypeResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class ResourceTypeResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'company_id' => $this->company_id,
            'timetable_id' => $this->timetable_id,
            'type' => $this->type,
            'name' => $this->name,
            'description' => $this->description,
            'options' => $this->options,
            'resource_config' => $this->resource_config,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
            'company' => new CompanyResource($this->whenLoaded('company')),
            'timetable' => new TimetableResource($this->whenLoaded('timetable')),
            'resources' => ResourceResource::collection($this->whenLoaded('resources')),
        ];
    }
}



=== app/Http/Resources/ResourceResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class ResourceResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'company_id' => $this->company_id,
            'timetable_id' => $this->timetable_id,
            'resource_type_id' => $this->resource_type_id,
            'options' => $this->options,
            'payload' => $this->payload,
            'resource_config' => $this->resource_config,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
            'company' => new CompanyResource($this->whenLoaded('company')),
            'timetable' => new TimetableResource($this->whenLoaded('timetable')),
            'resource_type' => new ResourceTypeResource($this->whenLoaded('resourceType')),
        ];
    }
}



=== app/Http/Resources/TimetableResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class TimetableResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'company_id' => $this->company_id,
            'type' => $this->type,
            'schedule' => $this->schedule,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
            'company' => new CompanyResource($this->whenLoaded('company')),
            'resource_types' => ResourceTypeResource::collection($this->whenLoaded('resourceTypes')),
            'resources' => ResourceResource::collection($this->whenLoaded('resources')),
        ];
    }
}



=== app/Http/Resources/BookingResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class BookingResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'company_id' => $this->company_id,
            'resource_id' => $this->resource_id,
            'timetable_id' => $this->timetable_id,
            'is_group_booking' => $this->is_group_booking,
            'start' => $this->start,
            'end' => $this->end,
            'status' => $this->status,
            'reason' => $this->reason,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
            'resource' => new ResourceResource($this->whenLoaded('resource')),
            'company' => new CompanyResource($this->whenLoaded('company')),
            'timetable' => new TimetableResource($this->whenLoaded('timetable')),
            'bookers' => BookerResource::collection($this->whenLoaded('bookers')),
        ];
    }
}



=== app/Http/Resources/SlotResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class SlotResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'start' => $this->resource['start'],
            'end' => $this->resource['end'],
            'duration_minutes' => $this->resource['duration_minutes'],
        ];
    }
}



=== app/Http/Resources/BookerResource.php ===
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class BookerResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'external_id' => $this->external_id,
            'type' => $this->type,
            'name' => $this->name,
            'email' => $this->email,
            'phone' => $this->phone,
            'metadata' => $this->metadata,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
        ];
    }
}



=== app/Http/Kernel.php ===
<?php

namespace App\Http;

use Illuminate\Foundation\Http\Kernel as HttpKernel;

class Kernel extends HttpKernel
{
    /**
     * The application's global HTTP middleware stack.
     *
     * These middleware are run during every request to your application.
     *
     * @var array<int, class-string|string>
     */
    protected $middleware = [
        // \App\Http\Middleware\TrustHosts::class,
        \App\Http\Middleware\TrustProxies::class,
        \Illuminate\Http\Middleware\HandleCors::class,
        \App\Http\Middleware\PreventRequestsDuringMaintenance::class,
        \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,
        \App\Http\Middleware\TrimStrings::class,
        \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,
    ];

    /**
     * The application's route middleware groups.
     *
     * @var array<string, array<int, class-string|string>>
     */
    protected $middlewareGroups = [
        'web' => [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            \Illuminate\View\Middleware\ShareErrorsFromSession::class,
            \App\Http\Middleware\VerifyCsrfToken::class,
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
        ],

        'api' => [
            // \Laravel\Sanctum\Http\Middleware\EnsureFrontendRequestsAreStateful::class,
            \Illuminate\Routing\Middleware\ThrottleRequests::class.':api',
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
        ],
    ];

    /**
     * The application's middleware aliases.
     *
     * Aliases may be used instead of class names to conveniently assign middleware to routes and groups.
     *
     * @var array<string, class-string|string>
     */
    protected $middlewareAliases = [
        'auth' => \App\Http\Middleware\Authenticate::class,
        'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
        'auth.session' => \Illuminate\Session\Middleware\AuthenticateSession::class,
        'cache.headers' => \Illuminate\Http\Middleware\SetCacheHeaders::class,
        'can' => \Illuminate\Auth\Middleware\Authorize::class,
        'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
        'password.confirm' => \Illuminate\Auth\Middleware\RequirePassword::class,
        'precognitive' => \Illuminate\Foundation\Http\Middleware\HandlePrecognitiveRequests::class,
        'signed' => \App\Http\Middleware\ValidateSignature::class,
        'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
        'verified' => \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
    ];
}



=== app/Http/Controllers/Api/TimetableImportController.php ===
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Actions\CreateTimetableFromJsonAction;
use App\Http\Requests\ImportTimetableRequest;
use App\Http\Resources\TimetableResource;
use Illuminate\Http\JsonResponse;

class TimetableImportController extends Controller
{
    public function __construct(
        private CreateTimetableFromJsonAction $createTimetableFromJsonAction
    ) {}

    public function importFromJson(ImportTimetableRequest $request): JsonResponse
    {
        try {
            $timetable = $this->createTimetableFromJsonAction->execute(
                $request->company_id,
                $request->schedule_data,
                $request->type
            );

            return response()->json([
                'data' => new TimetableResource($timetable),
                'message' => 'Timetable imported successfully from JSON'
            ], 201);

        } catch (\Exception $e) {
            return response()->json([
                'error' => $e->getMessage()
            ], 422);
        }
    }

    public function importFromFile(ImportTimetableRequest $request): JsonResponse
    {
        try {
            $fileContent = file_get_contents($request->file('schedule_file')->getPathname());
            $scheduleData = json_decode($fileContent, true);

            if (json_last_error() !== JSON_ERROR_NONE) {
                throw new \Exception('Invalid JSON file: ' . json_last_error_msg());
            }

            $timetable = $this->createTimetableFromJsonAction->execute(
                $request->company_id,
                $scheduleData,
                $request->type
            );

            return response()->json([
                'data' => new TimetableResource($timetable),
                'message' => 'Timetable imported successfully from file'
            ], 201);

        } catch (\Exception $e) {
            return response()->json([
                'error' => $e->getMessage()
            ], 422);
        }
    }
}



=== app/Http/Controllers/Api/BookingController.php ===
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Http\Requests\CheckAvailabilityRequest;
use App\Http\Requests\GetResourceBookingsRequest;
use App\Models\Booking;
use App\Models\Resource;
use App\Services\Booking\BookingService;
use App\Services\Booking\SlotGenerationService;
use App\Actions\CreateBookingAction;
use App\Actions\ConfirmBookingAction;
use App\Actions\CancelBookingAction;
use App\Actions\RescheduleBookingAction;
use App\Http\Requests\CreateBookingRequest;
use App\Http\Requests\RescheduleBookingRequest;
use App\Http\Requests\CancelBookingRequest;
use App\Http\Requests\GetSlotsRequest;
use App\Http\Resources\BookingResource;
use App\Http\Resources\ResourceResource;
use App\Http\Resources\SlotResource;
use Illuminate\Http\JsonResponse;
use Carbon\Carbon;

class BookingController extends Controller
{
    public function __construct(
        private BookingService $bookingService,
        private SlotGenerationService $slotService,
        private CreateBookingAction $createBookingAction,
        private ConfirmBookingAction $confirmBookingAction,
        private CancelBookingAction $cancelBookingAction,
        private RescheduleBookingAction $rescheduleBookingAction
    ) {}

    public function getResources(): JsonResponse
    {
        $resources = Resource::with(['company', 'resourceType', 'timetable'])->get();
        return response()->json(ResourceResource::collection($resources));
    }

    public function getAvailableSlots($resourceId, GetSlotsRequest $request): JsonResponse
    {
        $resource = Resource::findOrFail($resourceId);
        $date = $request->get('date', now()->toDateString());
        $count = $request->get('count', 10);
        $onlyToday = $request->get('only_today', true);

        $from = Carbon::parse($date);
        $slots = $this->bookingService->getNextAvailableSlots($resource, $from, $count, $onlyToday);

        return response()->json(SlotResource::collection($slots));
    }

    public function createBooking(CreateBookingRequest $request): JsonResponse
    {
        try {
            $resource = Resource::findOrFail($request->resource_id);

            $booking = $this->createBookingAction->execute(
                $resource,
                $request->start,
                $request->end,
                $request->booker ?? [],
                $request->is_admin ?? false
            );

            return response()->json([
                'data' => new BookingResource($booking),
                'message' => $booking->status === 'pending'
                    ? 'Бронь создана и ожидает подтверждения'
                    : 'Бронь успешно создана и подтверждена'
            ], 201);

        } catch (\Exception $e) {
            return response()->json([
                'error' => $e->getMessage()
            ], 422);
        }
    }

    public function confirmBooking($id): JsonResponse
    {
        try {
            $booking = $this->confirmBookingAction->execute($id);

            return response()->json([
                'data' => new BookingResource($booking),
                'message' => 'Бронь успешно подтверждена'
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => $e->getMessage()
            ], 422);
        }
    }

    public function cancelBooking($id, CancelBookingRequest $request): JsonResponse
    {
        try {
            $booking = $this->cancelBookingAction->execute(
                $id,
                $request->cancelled_by ?? 'client',
                $request->reason
            );

            return response()->json([
                'data' => new BookingResource($booking),
                'message' => 'Бронь успешно отменена'
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => $e->getMessage()
            ], 422);
        }
    }

    public function rescheduleBooking($id, RescheduleBookingRequest $request): JsonResponse
    {
        try {
            $booking = $this->rescheduleBookingAction->execute(
                $id,
                $request->new_start,
                $request->new_end,
                $request->requested_by ?? 'client'
            );

            return response()->json([
                'data' => new BookingResource($booking),
                'message' => 'Бронь успешно перенесена'
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => $e->getMessage()
            ], 422);
        }
    }

    public function getBookingsForResource($id, GetResourceBookingsRequest $request): JsonResponse
    {
        $resource = Resource::findOrFail($id);
        $bookings = $this->bookingService->getBookingsForResourceInRange(
            $resource,
            $request->from,
            $request->to
        );

        return response()->json(BookingResource::collection($bookings));
    }

    public function checkSlotAvailability(CheckAvailabilityRequest $request): JsonResponse
    {
        $resource = Resource::findOrFail($request->resource_id);

        if ($request->has('slots')) {
            $available = $this->bookingService->isSlotAvailable(
                $resource,
                $request->start,
                $request->slots
            );
        } else {
            $available = $this->bookingService->isRangeAvailable(
                $resource,
                Carbon::parse($request->start),
                Carbon::parse($request->end)
            );
        }

        return response()->json([
            'available' => $available,
            'message' => $available
                ? 'Слот доступен для бронирования'
                : 'Слот уже занят или недоступен'
        ]);
    }
}



=== app/Http/Controllers/TimetableController.php ===
<?php

namespace App\Http\Controllers;

use App\Actions\CreateOrUpdateCompanyAction;
use App\Actions\StoreTimetableAction;
use App\Actions\UpdateTimetableAction;
use App\Http\Requests\StoreTimetableRequest;
use App\Http\Requests\UpdateTimetableRequest;
use App\Http\Resources\TimetableResource;
use App\Models\Timetable;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;

class TimetableController extends Controller
{
    public function __construct(
        private CreateOrUpdateCompanyAction $createOrUpdateCompanyAction,
        private StoreTimetableAction $storeTimetableAction,
        private UpdateTimetableAction $updateTimetableAction
    ) {}

    public function index(): AnonymousResourceCollection
    {
        $timetables = Timetable::with(['company', 'resourceTypes', 'resources'])->get();
        return TimetableResource::collection($timetables);
    }

    public function store(StoreTimetableRequest $request): TimetableResource
    {
        $data = $request->validated();

        // Создаем или обновляем компанию
        $this->createOrUpdateCompanyAction->execute($data['company_id']);

        $timetable = $this->storeTimetableAction->execute($data);

        return new TimetableResource($timetable->load(['company', 'resourceTypes', 'resources']));
    }

    public function show(Timetable $timetable): TimetableResource
    {
        return new TimetableResource($timetable->load(['company', 'resourceTypes', 'resources']));
    }

    public function update(UpdateTimetableRequest $request, Timetable $timetable): TimetableResource
    {
        $data = $request->validated();

        $timetable = $this->updateTimetableAction->execute($timetable, $data);

        return new TimetableResource($timetable->load(['company', 'resourceTypes', 'resources']));
    }

    public function destroy(Timetable $timetable): JsonResponse
    {
        $timetable->delete();
        return response()->json(['message' => 'Timetable deleted successfully']);
    }

    public function attachResource(Timetable $timetable, Request $request): JsonResponse
    {
        $request->validate([
            'resource_id' => 'required|exists:resources,id'
        ]);

        $resource = \App\Models\Resource::find($request->resource_id);
        $resource->update(['timetable_id' => $timetable->id]);

        return response()->json(['message' => 'Resource attached to timetable successfully']);
    }

    public function detachResource(Timetable $timetable, Request $request): JsonResponse
    {
        $request->validate([
            'resource_id' => 'required|exists:resources,id'
        ]);

        $resource = \App\Models\Resource::find($request->resource_id);
        if ($resource->timetable_id === $timetable->id) {
            $resource->update(['timetable_id' => null]);
        }

        return response()->json(['message' => 'Resource detached from timetable successfully']);
    }

    public function attachResourceType(Timetable $timetable, Request $request): JsonResponse
    {
        $request->validate([
            'resource_type_id' => 'required|exists:resource_types,id'
        ]);

        $resourceType = \App\Models\ResourceType::find($request->resource_type_id);
        $resourceType->update(['timetable_id' => $timetable->id]);

        return response()->json(['message' => 'Resource type attached to timetable successfully']);
    }

    public function detachResourceType(Timetable $timetable, Request $request): JsonResponse
    {
        $request->validate([
            'resource_type_id' => 'required|exists:resource_types,id'
        ]);

        $resourceType = \App\Models\ResourceType::find($request->resource_type_id);
        if ($resourceType->timetable_id === $timetable->id) {
            $resourceType->update(['timetable_id' => null]);
        }

        return response()->json(['message' => 'Resource type detached from timetable successfully']);
    }
}



=== app/Http/Controllers/CompanyController.php ===
<?php

namespace App\Http\Controllers;

use App\Http\Requests\StoreCompanyRequest;
use App\Http\Resources\CompanyResource;
use App\Models\Company;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;

class CompanyController extends Controller
{
    public function index(): AnonymousResourceCollection
    {
        $companies = Company::all();
        return CompanyResource::collection($companies);
    }

    public function store(StoreCompanyRequest $request): CompanyResource
    {
        $company = Company::create($request->validated());
        return new CompanyResource($company);
    }

    public function show(Company $company): CompanyResource
    {
        return new CompanyResource($company);
    }

    public function update(StoreCompanyRequest $request, Company $company): CompanyResource
    {
        $company->update($request->validated());
        return new CompanyResource($company);
    }

    public function destroy(Company $company): JsonResponse
    {
        $company->delete();
        return response()->json(['message' => 'Company deleted successfully']);
    }
}



=== app/Http/Controllers/ResourceTypeController.php ===
<?php

namespace App\Http\Controllers;

use App\Actions\CreateOrUpdateCompanyAction;
use App\Actions\StoreResourceTypeAction;
use App\Http\Requests\StoreResourceTypeRequest;
use App\Http\Resources\ResourceTypeResource;
use App\Models\ResourceType;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;

class ResourceTypeController extends Controller
{
    public function __construct(
        private CreateOrUpdateCompanyAction $createOrUpdateCompanyAction,
        private StoreResourceTypeAction $storeResourceTypeAction
    ) {}

    public function index(): AnonymousResourceCollection
    {
        $resourceTypes = ResourceType::with(['company', 'timetable', 'resources'])->get();
        return ResourceTypeResource::collection($resourceTypes);
    }

    public function store(StoreResourceTypeRequest $request): ResourceTypeResource
    {
        $data = $request->validated();

        // Создаем или обновляем компанию если указан company_id
        if (isset($data['company_id'])) {
            $this->createOrUpdateCompanyAction->execute($data['company_id']);
        }

        $resourceType = $this->storeResourceTypeAction->execute($data);

        return new ResourceTypeResource($resourceType->load(['company', 'timetable', 'resources']));
    }

    public function show(ResourceType $resourceType): ResourceTypeResource
    {
        return new ResourceTypeResource($resourceType->load(['company', 'timetable', 'resources']));
    }

    public function update(StoreResourceTypeRequest $request, ResourceType $resourceType): ResourceTypeResource
    {
        $resourceType->update($request->validated());
        return new ResourceTypeResource($resourceType->load(['company', 'timetable', 'resources']));
    }

    public function destroy(ResourceType $resourceType): JsonResponse
    {
        $resourceType->delete();
        return response()->json(['message' => 'Resource type deleted successfully']);
    }
}



=== app/Http/Controllers/ResourceController.php ===
<?php

namespace App\Http\Controllers;

use App\Actions\CreateOrUpdateCompanyAction;
use App\Actions\StoreResourceAction;
use App\Http\Requests\StoreResourceRequest;
use App\Http\Resources\ResourceResource;
use App\Models\Resource;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;

class ResourceController extends Controller
{
    public function __construct(
        private CreateOrUpdateCompanyAction $createOrUpdateCompanyAction,
        private StoreResourceAction $storeResourceAction
    ) {}

    public function index(): AnonymousResourceCollection
    {
        $resources = Resource::with(['company', 'timetable', 'resourceType'])->get();
        return ResourceResource::collection($resources);
    }

    public function store(StoreResourceRequest $request): ResourceResource
    {
        $data = $request->validated();

        // Создаем или обновляем компанию если указан company_id
        if (isset($data['company_id'])) {
            $this->createOrUpdateCompanyAction->execute($data['company_id']);
        }

        $resource = $this->storeResourceAction->execute($data);

        return new ResourceResource($resource->load(['company', 'timetable', 'resourceType']));
    }

    public function show(Resource $resource): ResourceResource
    {
        return new ResourceResource($resource->load(['company', 'timetable', 'resourceType']));
    }

    public function update(StoreResourceRequest $request, Resource $resource): ResourceResource
    {
        $resource->update($request->validated());
        return new ResourceResource($resource->load(['company', 'timetable', 'resourceType']));
    }

    public function destroy(Resource $resource): JsonResponse
    {
        $resource->delete();
        return response()->json(['message' => 'Resource deleted successfully']);
    }
}



=== app/Http/Controllers/Controller.php ===
<?php

namespace App\Http\Controllers;

use Illuminate\Foundation\Auth\Access\AuthorizesRequests;
use Illuminate\Foundation\Validation\ValidatesRequests;
use Illuminate\Routing\Controller as BaseController;

class Controller extends BaseController
{
    use AuthorizesRequests, ValidatesRequests;
}



=== app/Http/Requests/CreateBookingRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class CreateBookingRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'resource_id' => 'required|exists:resources,id',
            'start' => 'required|date',
            'end' => 'required|date|after:start',
            'booker' => 'sometimes|array',
            'booker.external_id' => 'sometimes|string',
            'booker.type' => 'required|in:client,admin,employee',
            'booker.name' => 'sometimes|string',
            'booker.email' => 'sometimes|email',
            'booker.phone' => 'sometimes|string',
            'booker.metadata' => 'sometimes|array',
            'is_admin' => 'sometimes|boolean'
        ];
    }
}



=== app/Http/Requests/StoreResourceTypeRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreResourceTypeRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'company_id' => 'sometimes|integer|min:1',
            'timetable_id' => 'nullable|integer|exists:timetables,id',
            'type' => 'required|string|max:63',
            'name' => 'required|string|max:127',
            'description' => 'nullable|string|max:255',
            'options' => 'nullable|array',
            'resource_config' => 'nullable|array',
        ];
    }
}



=== app/Http/Requests/GetResourceBookingsRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class GetResourceBookingsRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'from' => 'required|date',
            'to' => 'required|date|after:from'
        ];
    }
}



=== app/Http/Requests/UpdateTimetableRequest.php ===
<?php

namespace App\Http\Requests;

use App\Enums\TimetableType;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

class UpdateTimetableRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'type' => ['sometimes', 'string', Rule::in(TimetableType::values())],
            'schedule' => 'sometimes|array',
            'schedule.days' => 'required_if:type,static|array',
            'schedule.days.*.working_hours' => 'required_if:type,static|array',
            'schedule.days.*.working_hours.start' => 'required_if:type,static|date_format:H:i',
            'schedule.days.*.working_hours.end' => 'required_if:type,static|date_format:H:i',
            'schedule.days.*.breaks' => 'sometimes|array',
            'schedule.days.*.breaks.*.start' => 'required_with:schedule.days.*.breaks|date_format:H:i',
            'schedule.days.*.breaks.*.end' => 'required_with:schedule.days.*.breaks|date_format:H:i',
            'schedule.holidays' => 'sometimes|array',
            'schedule.holidays.*' => 'string|regex:/^\d{2}-\d{2}$/',
            'schedule.dates' => 'required_if:type,dinamic|array',
            'schedule.dates.*.working_hours' => 'required_if:type,dinamic|array',
            'schedule.dates.*.working_hours.start' => 'required_if:type,dinamic|date_format:H:i',
            'schedule.dates.*.working_hours.end' => 'required_if:type,dinamic|date_format:H:i',
            'schedule.dates.*.breaks' => 'sometimes|array',
            'schedule.dates.*.breaks.*.start' => 'required_with:schedule.dates.*.breaks|date_format:H:i',
            'schedule.dates.*.breaks.*.end' => 'required_with:schedule.dates.*.breaks|date_format:H:i',
        ];
    }
}



=== app/Http/Requests/StoreCompanyRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreCompanyRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'name' => 'nullable|string|max:255',
            'description' => 'nullable|string',
        ];
    }
}



=== app/Http/Requests/CheckAvailabilityRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class CheckAvailabilityRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'resource_id' => 'required|exists:resources,id',
            'start' => 'required|date',
            'end' => 'required|date|after:start',
            'slots' => 'sometimes|integer|min:1'
        ];
    }
}



=== app/Http/Requests/GetSlotsRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class GetSlotsRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'date' => 'sometimes|date',
            'count' => 'sometimes|integer|min:1|max:50',
            'only_today' => 'sometimes|boolean'
        ];
    }
}



=== app/Http/Requests/StoreResourceRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreResourceRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'company_id' => 'sometimes|integer|min:1',
            'timetable_id' => 'nullable|integer|exists:timetables,id',
            'resource_type_id' => 'required|integer|exists:resource_types,id',
            'options' => 'nullable|array',
            'payload' => 'nullable|array',
            'resource_config' => 'nullable|array',
        ];
    }
}



=== app/Http/Requests/RescheduleBookingRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class RescheduleBookingRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'new_start' => 'required|date',
            'new_end' => 'required|date|after:new_start',
            'requested_by' => 'sometimes|in:client,admin'
        ];
    }
}



=== app/Http/Requests/StoreTimetableRequest.php ===
<?php

namespace App\Http\Requests;

use App\Enums\TimetableType;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

class StoreTimetableRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'company_id' => 'required|integer|min:1',
            'type' => ['required', 'string', Rule::in(TimetableType::values())],
            'schedule' => 'required|array',
            'schedule.days' => 'required_if:type,static|array',
            'schedule.days.*.working_hours' => 'required_if:type,static|array',
            'schedule.days.*.working_hours.start' => 'required_if:type,static|date_format:H:i',
            'schedule.days.*.working_hours.end' => 'required_if:type,static|date_format:H:i',
            'schedule.days.*.breaks' => 'sometimes|array',
            'schedule.days.*.breaks.*.start' => 'required_with:schedule.days.*.breaks|date_format:H:i',
            'schedule.days.*.breaks.*.end' => 'required_with:schedule.days.*.breaks|date_format:H:i',
            'schedule.holidays' => 'sometimes|array',
            'schedule.holidays.*' => 'string|regex:/^\d{2}-\d{2}$/',
            'schedule.dates' => 'required_if:type,dinamic|array',
            'schedule.dates.*.working_hours' => 'required_if:type,dinamic|array',
            'schedule.dates.*.working_hours.start' => 'required_if:type,dinamic|date_format:H:i',
            'schedule.dates.*.working_hours.end' => 'required_if:type,dinamic|date_format:H:i',
            'schedule.dates.*.breaks' => 'sometimes|array',
            'schedule.dates.*.breaks.*.start' => 'required_with:schedule.dates.*.breaks|date_format:H:i',
            'schedule.dates.*.breaks.*.end' => 'required_with:schedule.dates.*.breaks|date_format:H:i',
        ];
    }

    public function messages(): array
    {
        return [
            'schedule.holidays.*.regex' => 'Holiday format must be MM-DD',
            'schedule.days.*.working_hours.start.date_format' => 'Start time must be in HH:MM format',
            'schedule.days.*.working_hours.end.date_format' => 'End time must be in HH:MM format',
            'schedule.dates.*.working_hours.start.date_format' => 'Start time must be in HH:MM format',
            'schedule.dates.*.working_hours.end.date_format' => 'End time must be in HH:MM format',
        ];
    }
}



=== app/Http/Requests/CancelBookingRequest.php ===
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class CancelBookingRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'cancelled_by' => 'sometimes|in:client,admin',
            'reason' => 'sometimes|string|max:255'
        ];
    }
}



=== app/Http/Requests/ImportTimetableRequest.php ===
<?php

namespace App\Http\Requests;

use App\Enums\TimetableType;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

class ImportTimetableRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'company_id' => 'required|integer|exists:companies,id',
            'type' => ['required', 'string', Rule::in(TimetableType::values())],
            'schedule_data' => 'required_without:schedule_file|array',
            'schedule_file' => 'required_without:schedule_data|file|mimes:json|max:10240',
        ];
    }

    public function messages(): array
    {
        return [
            'schedule_file.mimes' => 'The file must be a JSON file',
            'schedule_file.max' => 'The file size must not exceed 10MB',
        ];
    }
}



=== app/Http/Middleware/VerifyCsrfToken.php ===
<?php

namespace App\Http\Middleware;

use Illuminate\Foundation\Http\Middleware\VerifyCsrfToken as Middleware;

class VerifyCsrfToken extends Middleware
{
    /**
     * The URIs that should be excluded from CSRF verification.
     *
     * @var array<int, string>
     */
    protected $except = [
        //
    ];
}



=== app/Http/Middleware/TrimStrings.php ===
<?php

namespace App\Http\Middleware;

use Illuminate\Foundation\Http\Middleware\TrimStrings as Middleware;

class TrimStrings extends Middleware
{
    /**
     * The names of the attributes that should not be trimmed.
     *
     * @var array<int, string>
     */
    protected $except = [
        'current_password',
        'password',
        'password_confirmation',
    ];
}



=== app/Http/Middleware/EncryptCookies.php ===
<?php

namespace App\Http\Middleware;

use Illuminate\Cookie\Middleware\EncryptCookies as Middleware;

class EncryptCookies extends Middleware
{
    /**
     * The names of the cookies that should not be encrypted.
     *
     * @var array<int, string>
     */
    protected $except = [
        //
    ];
}



=== app/Http/Middleware/TrustProxies.php ===
<?php

namespace App\Http\Middleware;

use Illuminate\Http\Middleware\TrustProxies as Middleware;
use Illuminate\Http\Request;

class TrustProxies extends Middleware
{
    /**
     * The trusted proxies for this application.
     *
     * @var array<int, string>|string|null
     */
    protected $proxies;

    /**
     * The headers that should be used to detect proxies.
     *
     * @var int
     */
    protected $headers =
        Request::HEADER_X_FORWARDED_FOR |
        Request::HEADER_X_FORWARDED_HOST |
        Request::HEADER_X_FORWARDED_PORT |
        Request::HEADER_X_FORWARDED_PROTO |
        Request::HEADER_X_FORWARDED_AWS_ELB;
}



=== app/Http/Middleware/PreventRequestsDuringMaintenance.php ===
<?php

namespace App\Http\Middleware;

use Illuminate\Foundation\Http\Middleware\PreventRequestsDuringMaintenance as Middleware;

class PreventRequestsDuringMaintenance extends Middleware
{
    /**
     * The URIs that should be reachable while maintenance mode is enabled.
     *
     * @var array<int, string>
     */
    protected $except = [
        //
    ];
}



=== app/Http/Middleware/Authenticate.php ===
<?php

namespace App\Http\Middleware;

use Illuminate\Auth\Middleware\Authenticate as Middleware;
use Illuminate\Http\Request;

class Authenticate extends Middleware
{
    /**
     * Get the path the user should be redirected to when they are not authenticated.
     */
    protected function redirectTo(Request $request): ?string
    {
        return $request->expectsJson() ? null : route('login');
    }
}



=== app/Http/Middleware/ValidateSignature.php ===
<?php

namespace App\Http\Middleware;

use Illuminate\Routing\Middleware\ValidateSignature as Middleware;

class ValidateSignature extends Middleware
{
    /**
     * The names of the query string parameters that should be ignored.
     *
     * @var array<int, string>
     */
    protected $except = [
        // 'fbclid',
        // 'utm_campaign',
        // 'utm_content',
        // 'utm_medium',
        // 'utm_source',
        // 'utm_term',
    ];
}



=== app/Http/Middleware/RedirectIfAuthenticated.php ===
<?php

namespace App\Http\Middleware;

use App\Providers\RouteServiceProvider;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Symfony\Component\HttpFoundation\Response;

class RedirectIfAuthenticated
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next, string ...$guards): Response
    {
        $guards = empty($guards) ? [null] : $guards;

        foreach ($guards as $guard) {
            if (Auth::guard($guard)->check()) {
                return redirect(RouteServiceProvider::HOME);
            }
        }

        return $next($request);
    }
}



=== app/Http/Middleware/TrustHosts.php ===
<?php

namespace App\Http\Middleware;

use Illuminate\Http\Middleware\TrustHosts as Middleware;

class TrustHosts extends Middleware
{
    /**
     * Get the host patterns that should be trusted.
     *
     * @return array<int, string|null>
     */
    public function hosts(): array
    {
        return [
            $this->allSubdomainsOfApplicationUrl(),
        ];
    }
}



=== app/Console/Kernel.php ===
<?php

namespace App\Console;

use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;

class Kernel extends ConsoleKernel
{
    /**
     * Define the application's command schedule.
     */
    protected function schedule(Schedule $schedule): void
    {
        // $schedule->command('inspire')->hourly();
    }

    /**
     * Register the commands for the application.
     */
    protected function commands(): void
    {
        $this->load(__DIR__.'/Commands');

        require base_path('routes/console.php');
    }
}



=== app/Console/Commands/GenerateDinamicTimetable.php ===
<?php

namespace App\Console\Commands;

use App\Actions\CreateOrUpdateCompanyAction;
use App\Actions\CreateTimetableFromJsonAction;
use App\Models\Timetable;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Storage;
use Carbon\Carbon;

class GenerateDinamicTimetable extends Command
{
    protected $signature = 'timetable:generate-dinamic {company_id} {days=30}';
    protected $description = 'Generate dinamic timetable for specified period';

    public function handle(
        CreateOrUpdateCompanyAction $createOrUpdateCompanyAction,
        CreateTimetableFromJsonAction $createTimetableFromJsonAction
    ): void {
        $companyId = $this->argument('company_id');
        $daysCount = $this->argument('days');

        // Создаем или получаем компанию
        $company = $createOrUpdateCompanyAction->execute($companyId);

        $schedule = ['dates' => []];
        $startDate = now();

        for ($i = 0; $i < $daysCount; $i++) {
            $date = $startDate->copy()->addDays($i);

            // Пропускаем некоторые дни (30% вероятность для выходных)
            $dayOfWeek = $date->dayOfWeek;
            $isWeekend = ($dayOfWeek === 0 || $dayOfWeek === 6); // 0 - воскресенье, 6 - суббота

            if ($isWeekend && rand(1, 100) <= 70) {
                continue; // Пропускаем большинство выходных
            }

            if (!$isWeekend && rand(1, 100) <= 15) {
                continue; // Пропускаем некоторые будни
            }

            $dateKey = $date->format('m-d');

            // Генерируем уникальный график для каждого дня
            $schedule['dates'][$dateKey] = $this->generateDailySchedule();
        }

        $timetable = $createTimetableFromJsonAction->execute($companyId, $schedule, 'dinamic');

        // Сохраняем пример в файл
        Storage::put('exports/dinamic_timetable_example.json', json_encode($schedule, JSON_PRETTY_PRINT));

        $this->info("Dinamic timetable created successfully for company {$companyId}");
        $this->info("Generated schedule for " . count($schedule['dates']) . " days (some days skipped)");
        $this->info("Example saved to storage/app/exports/dinamic_timetable_example.json");
    }

    /**
     * Генерирует уникальный график для одного дня
     */
    private function generateDailySchedule(): array
    {
        $scheduleTypes = [
            '8h_normal' => ['start' => '09:00', 'end' => '17:00'],
            '8h_early' => ['start' => '08:00', 'end' => '16:00'],
            '8h_late' => ['start' => '10:00', 'end' => '18:00'],
            '10h' => ['start' => '08:00', 'end' => '18:00'],
            '12h' => ['start' => '08:00', 'end' => '20:00'],
            '24h' => ['start' => '08:00', 'end' => '08:00'], // Следующего дня
            '6h_short' => ['start' => '10:00', 'end' => '16:00'],
        ];

        // Выбираем случайный тип графика
        $scheduleType = array_rand($scheduleTypes);
        $workingHours = $scheduleTypes[$scheduleType];

        // Генерируем перерывы в зависимости от типа графика
        $breaks = $this->generateBreaksForSchedule($scheduleType, $workingHours);

        return [
            'working_hours' => $workingHours,
            'breaks' => $breaks,
            'schedule_type' => $scheduleType, // Для отладки
        ];
    }

    /**
     * Генерирует перерывы в зависимости от типа графика
     */
    private function generateBreaksForSchedule(string $scheduleType, array $workingHours): array
    {
        $breaks = [];

        switch ($scheduleType) {
            case '8h_normal':
            case '8h_early':
            case '8h_late':
                // 1-2 перерыва для 8-часового дня
                $breakCount = rand(1, 2);
                $breaks = $this->generateBreaks($workingHours, $breakCount, 30, 60);
                break;

            case '10h':
                // 2-3 перерыва для 10-часового дня
                $breakCount = rand(2, 3);
                $breaks = $this->generateBreaks($workingHours, $breakCount, 15, 45);
                break;

            case '12h':
                // 3-4 перерыва для 12-часового дня
                $breakCount = rand(3, 4);
                $breaks = $this->generateBreaks($workingHours, $breakCount, 15, 60);
                break;

            case '24h':
                // 4-6 перерывов для 24-часовой смены
                $breakCount = rand(4, 6);
                $breaks = $this->generate24hBreaks($breakCount);
                break;

            case '6h_short':
                // 0-1 перерыв для короткого дня
                $breakCount = rand(0, 1);
                if ($breakCount > 0) {
                    $breaks = $this->generateBreaks($workingHours, 1, 15, 30);
                }
                break;
        }

        return $breaks;
    }

    /**
     * Генерирует перерывы для обычного графика
     */
    private function generateBreaks(array $workingHours, int $breakCount, int $minDuration, int $maxDuration): array
    {
        $breaks = [];
        $startHour = (int)explode(':', $workingHours['start'])[0];
        $endHour = (int)explode(':', $workingHours['end'])[0];

        // Для 24-часовой смены
        if ($endHour <= $startHour) {
            $endHour += 24;
        }

        $workDuration = $endHour - $startHour;
        $interval = $workDuration / ($breakCount + 1);

        for ($i = 1; $i <= $breakCount; $i++) {
            $breakStartHour = $startHour + ($interval * $i);
            $breakDuration = rand($minDuration, $maxDuration);

            // Случайное смещение начала перерыва (±30 минут)
            $breakStartOffset = rand(-30, 30);
            $breakStartHour += $breakStartOffset / 60;

            $breakStart = $this->minutesToTime($breakStartHour * 60);
            $breakEnd = $this->minutesToTime(($breakStartHour * 60) + $breakDuration);

            $breaks[] = [
                'start' => $breakStart,
                'end' => $breakEnd,
                'duration_minutes' => $breakDuration,
            ];
        }

        return $breaks;
    }

    /**
     * Генерирует перерывы для 24-часовой смены
     */
    private function generate24hBreaks(int $breakCount): array
    {
        $breaks = [];
        $totalBreakMinutes = 180; // 3 часа суммарно
        $breakDuration = (int)($totalBreakMinutes / $breakCount);

        // Равномерно распределяем перерывы по 24-часовой смене
        $shiftDuration = 24 * 60; // 24 часа в минутах
        $interval = (int)($shiftDuration / ($breakCount + 1));

        for ($i = 1; $i <= $breakCount; $i++) {
            $breakStartMinutes = $interval * $i;
            $breakEndMinutes = $breakStartMinutes + $breakDuration;

            $breakStart = $this->minutesToTime($breakStartMinutes);
            $breakEnd = $this->minutesToTime($breakEndMinutes);

            $breaks[] = [
                'start' => $breakStart,
                'end' => $breakEnd,
                'duration_minutes' => $breakDuration,
            ];
        }

        return $breaks;
    }

    /**
     * Преобразует минуты в формат времени HH:MM
     */
    private function minutesToTime(int $totalMinutes): string
    {
        $hours = floor($totalMinutes / 60) % 24;
        $minutes = $totalMinutes % 60;

        return sprintf('%02d:%02d', $hours, $minutes);
    }
}



=== app/Console/Commands/GenerateTestBookingData.php ===
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Actions\GenerateTestDataAction;

class GenerateTestBookingData extends Command
{
    protected $signature = 'booking:generate-test-data {--company-id=}';
    protected $description = 'Generate test data for booking system using Artisan commands';

    public function handle(GenerateTestDataAction $generateTestDataAction): void
    {
        $companyId = $this->option('company-id') ?? 1;

        $this->info("🏢 Создание тестовых данных для компании {$companyId}...");
        $this->info("📋 Используются реальные Artisan команды для генерации расписаний");

        $result = $generateTestDataAction->execute($companyId);

        $this->info("🎉 Тестовые данные успешно созданы!");

        // Выводим детальную статистику
        $this->info("\n📊 Детальная статистика:");
        $this->info("   - Компания: {$result['company']->name} (ID: {$result['company']->id})");

        $this->info("   - Расписания:");
        $this->info("     • Статическое: {$result['timetable_info']['static']['working_days']} рабочих дней, {$result['timetable_info']['static']['total_breaks']} перерывов");
        $this->info("     • Динамическое: {$result['timetable_info']['dynamic']['working_days']} рабочих дней, {$result['timetable_info']['dynamic']['total_breaks']} перерывов");

        $this->info("   - Типы ресурсов: " . count($result['resource_types']));
        foreach ($result['resource_types'] as $type => $resourceType) {
            $this->info("     • {$resourceType->name}: {$resourceType->description}");
        }

        $resourcesByType = [];
        foreach ($result['resources'] as $resource) {
            $typeName = $resource->resourceType->name;
            $resourcesByType[$typeName] = ($resourcesByType[$typeName] ?? 0) + 1;
        }

        $this->info("   - Ресурсы: " . count($result['resources']));
        foreach ($resourcesByType as $typeName => $count) {
            $this->info("     • {$typeName}: {$count} шт.");
        }

        $this->info("   - Бронирования: " . count($result['bookings']));

        $bookingsByStatus = [];
        foreach ($result['bookings'] as $booking) {
            $bookingsByStatus[$booking->status] = ($bookingsByStatus[$booking->status] ?? 0) + 1;
        }

        foreach ($bookingsByStatus as $status => $count) {
            $this->info("     • {$status}: {$count} шт.");
        }

        $this->info("\n🚀 Система готова к тестированию!");
        $this->info("💡 Используйте: php artisan serve");
        $this->info("📚 API документация в Postman коллекции: storage/app/exports/booking_system_postman_collection.json");
    }
}



=== app/Console/Commands/DemoBookingScenarios.php ===
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Actions\CreateOrUpdateCompanyAction;
use App\Actions\CreateTimetableFromJsonAction;
use App\Actions\StoreResourceTypeAction;
use App\Actions\StoreResourceAction;
use App\Services\Logging\BookingLoggerService;
use App\Models\Company;
use App\Models\Resource;
use App\Http\Controllers\Api\BookingController;
use App\Http\Requests\CreateBookingRequest;
use App\Http\Requests\CancelBookingRequest;
use App\Http\Requests\RescheduleBookingRequest;
use App\Http\Requests\GetSlotsRequest;
use App\Http\Requests\CheckAvailabilityRequest;
use Illuminate\Http\Request;
use Carbon\Carbon;
use App\Services\Booking\BookingService; // Добавляем импорт


class DemoBookingScenarios extends Command
{
    protected $signature = 'demo:booking-scenarios
                            {scenario? : Конкретный сценарий для запуска (1-8)}
                            {--all : Запустить все сценарии}
                            {--list : Показать доступные сценарии}';

    protected $description = 'Запуск демонстрационных сценариев системы бронирования';

    private int $currentCompanyId;
    private int $currentResourceId;
    private BookingController $bookingController;


    public function __construct(
        private CreateOrUpdateCompanyAction $createCompanyAction,
        private CreateTimetableFromJsonAction $createTimetableAction,
        private StoreResourceTypeAction $storeResourceTypeAction,
        private StoreResourceAction $storeResourceAction,
        private BookingService $bookingService // Добавляем в конструктор
    ) {
        parent::__construct();
        $this->bookingController = app(BookingController::class);
    }

    public function handle(): int
    {
        if ($this->option('list')) {
            return $this->showScenarios();
        }

        $this->info('🚀 Запуск демонстрации системы бронирования');
        $this->line('==================================================');

        $scenarios = $this->getScenariosToRun();

        foreach ($scenarios as $scenario) {
            $this->runScenario($scenario);
        }

        $this->info('🎉 Все сценарии завершены!');
        BookingLoggerService::info('Демонстрация всех сценариев завершена');

        return 0;
    }

    /**
     * Показать список доступных сценариев с описанием
     */
    private function showScenarios(): int
    {
        $this->info('📋 ДОСТУПНЫЕ ДЕМОНСТРАЦИОННЫЕ СЦЕНАРИИ:');
        $this->line('');

        $scenarios = [
            1 => '💈 СЦЕНАРИЙ 1: Парикмахерская - Фиксированные слоты + автоматическое подтверждение',
            2 => '🏢 СЦЕНАРИЙ 2: Переговорная комната - Динамические слоты + ручное подтверждение',
            3 => '🏋️ СЦЕНАРИЙ 3: Групповая тренировка - Фиксированные слоты + групповые брони',
            4 => '💎 СЦЕНАРИЙ 4: Дорогое оборудование - Динамические слоты + строгие ограничения',
            5 => '🏨 СЦЕНАРИЙ 5: Гостиничный номер - Переходящие брони + разные стратегии',
            6 => '⚡ СЦЕНАРИЙ 6: Экстренный случай - Администратор vs Пользователь',
            7 => '💅 СЦЕНАРИЙ 7: Салон красоты - Статическое расписание с праздниками',
            8 => '🏢 СЦЕНАРИЙ 8: Бизнес-центр - Смешанное расписание + перерывы'
        ];

        foreach ($scenarios as $id => $description) {
            $this->line("  {$id}. {$description}");
        }

        $this->line("\n💡 Использование:");
        $this->line("  php artisan demo:booking-scenarios --all      # Запустить все сценарии");
        $this->line("  php artisan demo:booking-scenarios 1          # Запустить только сценарий 1");
        $this->line("  php artisan demo:booking-scenarios --list     # Показать этот список");

        return 0;
    }

    /**
     * Определить какие сценарии нужно запустить
     */
    private function getScenariosToRun(): array
    {
        if ($this->option('all')) {
            return range(1, 8);
        }

        $scenario = $this->argument('scenario');
        if ($scenario) {
            return [$scenario];
        }

        // Интерактивный выбор если не указаны параметры
        $choice = $this->choice(
            '🎯 Выберите сценарий для запуска:',
            [
                1 => '1. 💈 Парикмахерская (авто-подтверждение, фиксированные слоты)',
                2 => '2. 🏢 Переговорная (ручное подтверждение, динамические слоты)',
                3 => '3. 🏋️ Групповая тренировка (лимит участников, групповые брони)',
                4 => '4. 💎 Дорогое оборудование (строгие правила, подтверждение)',
                5 => '5. 🏨 Гостиничный номер (многодневные брони)',
                6 => '6. ⚡ Экстренный случай (админ vs пользователь)',
                7 => '7. 💅 Салон красоты (праздничные дни, перерывы)',
                8 => '8. 🏢 Бизнес-центр (сложное расписание, множественные перерывы)',
                'all' => 'ALL. 🚀 Запустить все сценарии'
            ],
            'all'
        );

        return $choice === 'all' ? range(1, 8) : [explode('.', $choice)[0]];
    }

    /**
     * Запуск конкретного сценария
     */
    private function runScenario(int $scenarioId): void
    {
        $this->info("\n🎬 ЗАПУСК СЦЕНАРИЯ {$scenarioId}");
        $this->line(str_repeat('─', 60));

        // Логирование начала сценария
        BookingLoggerService::info("Начало сценария {$scenarioId}", ['scenario_id' => $scenarioId]);

        // Очистка данных предыдущего запуска
        $this->cleanupScenarioData($scenarioId);

        // Настройка сценария: создание компании, расписания, ресурсов
        $setupData = $this->setupScenario($scenarioId);

        if (!$setupData) {
            $this->error("❌ Ошибка настройки сценария {$scenarioId}");
            BookingLoggerService::error("Сценарий {$scenarioId} не настроен");
            return;
        }

        $this->currentResourceId = $setupData['resource_id'];

        // Запуск конкретного сценария по номеру
        $method = "runScenario{$scenarioId}";
        if (method_exists($this, $method)) {
            $this->$method($setupData);
        } else {
            $this->error("❌ Метод {$method} не реализован");
        }

        $this->info("✅ Сценарий {$scenarioId} завершен");
        $this->storeScenarioResults($scenarioId, $setupData);

        // Логирование завершения сценария
        BookingLoggerService::info("Сценарий {$scenarioId} завершен", [
            'scenario_id' => $scenarioId,
            'resource_id' => $this->currentResourceId
        ]);
    }

    /**
     * Настройка окружения для сценария: компания, расписание, тип ресурса, ресурс
     */
    private function setupScenario(int $scenarioId): ?array
    {
        $this->info("⚙️ Настройка сценария {$scenarioId}...");

        // Создание компании с уникальным ID для сценария
        $companyId = $scenarioId * 100;
        $company = $this->createCompanyAction->execute(
            $companyId,
            "Демо компания Сценарий {$scenarioId}"
        );
        $this->currentCompanyId = $company->id;

        // Получение данных расписания для сценария
        $timetableData = $this->getTimetableForScenario($scenarioId);
        $timetable = $this->createTimetableAction->execute(
            $company->id,
            $timetableData['schedule'],
            $timetableData['type']
        );

        // Конфигурация типа ресурса
        $resourceTypeConfig = $this->getResourceConfigForScenario($scenarioId);
        $resourceTypeData = [
            'company_id' => $company->id,
            'timetable_id' => $timetable->id,
            'type' => "type_scenario_{$scenarioId}",
            'name' => "Тип ресурса Сценарий {$scenarioId}",
            'description' => $this->getScenarioDescription($scenarioId),
            'resource_config' => $resourceTypeConfig
        ];

        $resourceType = $this->storeResourceTypeAction->execute($resourceTypeData);

        // Создание конкретного ресурса
        $resourceData = [
            'company_id' => $company->id,
            'timetable_id' => $timetable->id,
            'resource_type_id' => $resourceType->id,
            'options' => $this->getResourceOptionsForScenario($scenarioId),
            'resource_config' => $this->getResourceOverridesForScenario($scenarioId)
        ];

        $resource = $this->storeResourceAction->execute($resourceData);

        // Вывод информации о настройке
        $this->info("✅ Компания: {$company->name} (ID: {$company->id})");
        $this->info("✅ Расписание: {$timetable->type}");
        $this->info("✅ Тип ресурса: {$resourceType->name}");
        $this->info("✅ Ресурс: {$this->getResourceName($scenarioId)} (ID: {$resource->id})");
        $this->info("📋 Конфигурация: " . $this->getConfigSummary($resourceTypeConfig));

        // Логирование успешной настройки
        BookingLoggerService::info("Сценарий {$scenarioId} настроен", [
            'company_id' => $company->id,
            'timetable_id' => $timetable->id,
            'resource_type_id' => $resourceType->id,
            'resource_id' => $resource->id
        ]);

        return [
            'company_id' => $company->id,
            'timetable_id' => $timetable->id,
            'resource_type_id' => $resourceType->id,
            'resource_id' => $resource->id
        ];
    }

    /**
     * ===========================================================================
     * СЦЕНАРИЙ 1: Парикмахерская - Фиксированные слоты + автоматическое подтверждение
     * ===========================================================================
     */
    private function runScenario1(array $setupData): void
    {
        $resourceId = $setupData['resource_id'];

        $this->info("\n💈 СЦЕНАРИЙ 1: ПАРИКМАХЕРСКАЯ");
        $this->line("🎯 Цель: Демонстрация фиксированных слотов с автоматическим подтверждением");
        $this->line("📋 Параметры: авто-подтверждение, фиксированные слоты 60 мин, перерыв 13:15-14:15");

        BookingLoggerService::info("Начало Сценария 1: Парикмахерская");

        // ШАГ 1: Получить доступные слоты для отображения пользователю
        $this->info("\n📅 ШАГ 1: Получение доступных слотов...");
        $slots = $this->getSlots($resourceId, '2024-01-15', 8);
        $this->info("   📊 Доступные слоты: " . count($slots));
        $this->info("   🕒 Примеры: " . implode(', ', array_slice($slots, 0, 3)));

        // ШАГ 2: Создать бронь на последний слот до перерыва
        $this->info("\n✅ ШАГ 2: Бронь последнего слота до перерыва...");
        $booking1 = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => '2024-01-15 12:00:00',
            'end' => '2024-01-15 13:00:00',
            'booker' => ['name' => 'Анна Иванова', 'email' => 'anna@example.com']
        ]);
        $this->checkStatus($booking1, 'confirmed', "Бронь авто-подтверждена");

        // ШАГ 3: Попытка брони с пересечением перерыва (должна быть ошибка)
        $this->info("\n❌ ШАГ 3: Попытка брони с пересечением перерыва...");
        try {
            $this->createBooking([
                'resource_id' => $resourceId,
                'start' => '2024-01-15 12:45:00',
                'end' => '2024-01-15 13:45:00',
                'booker' => ['name' => 'Конфликтный клиент']
            ]);
            $this->error("   🚨 НЕОЖИДАННО: Должно было быть ошибкой!");
        } catch (\Exception $e) {
            $this->info("   ✅ Ожидаемая ошибка: {$e->getMessage()}");
        }

        // ШАГ 4: Бронь первого слота после перерыва
        $this->info("\n✅ ШАГ 4: Бронь первого слота после перерыва...");
        $booking2 = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => '2024-01-15 14:15:00',
            'end' => '2024-01-15 15:15:00',
            'booker' => ['name' => 'Петр Сидоров']
        ]);
        $this->checkStatus($booking2, 'confirmed', "Бронь после перерыва создана");

        // ДОБАВЛЯЕМ ОТЛАДОЧНУЮ ИНФОРМАЦИЮ
        $this->info("\n🔍 Отладочная информация о расписании:");
        $this->debugTimetableInfo($resourceId);

        // ШАГ 5: Проверка доступности пограничных слотов
        $this->info("\n🔍 ШАГ 5: Проверка пограничных случаев...");
        $this->testBoundaryCases($resourceId);

        // ШАГ 6: Отмена брони клиентом
        $this->info("\n🔄 ШАГ 6: Отмена брони клиентом...");
        $canceledBooking = $this->cancelBooking($booking1['id'], 'client', 'Планы изменились');
        $this->checkStatus($canceledBooking, 'cancelled_by_client', "Бронь отменена клиентом");

        $this->info("\n🎉 СЦЕНАРИЙ 1 ЗАВЕРШЕН: Все функции фиксированных слотов работают корректно!");
    }

    /**
     * ===========================================================================
     * СЦЕНАРИЙ 2: Переговорная комната - Динамические слоты + ручное подтверждение
     * ===========================================================================
     */
    private function runScenario2(array $setupData): void
    {
        $resourceId = $setupData['resource_id'];

        $this->info("\n🏢 СЦЕНАРИЙ 2: ПЕРЕГОВОРНАЯ КОМНАТА");
        $this->line("🎯 Цель: Демонстрация динамических слотов с ручным подтверждением");
        $this->line("📋 Параметры: ручное подтверждение, динамические слоты 30 мин, разные права доступа");

        // ШАГ 1: Администратор создает бронь вне стандартного расписания
        $this->info("\n👨‍💼 ШАГ 1: Администратор создает бронь вне расписания...");
        $adminBooking = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => '2024-01-16 10:00:00',
            'end' => '2024-01-16 11:30:00',
            'is_admin' => true,
            'booker' => ['name' => 'Администратор', 'type' => 'admin']
        ]);
        $this->checkStatus($adminBooking, 'confirmed', "Бронь администратора авто-подтверждена");

        // ШАГ 2: Пользователь создает бронь (требует подтверждения)
        $this->info("\n👤 ШАГ 2: Пользователь создает бронь (требует подтверждения)...");
        $userBooking = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => '2024-01-16 13:00:00',
            'end' => '2024-01-16 14:00:00',
            'booker' => ['name' => 'Петр Сидоров', 'email' => 'peter@example.com']
        ]);
        $this->checkStatus($userBooking, 'pending', "Бронь пользователя ожидает подтверждения");

        // ШАГ 3: Проверить слоты с учетом pending брони
        $this->info("\n📅 ШАГ 3: Проверка слотов с учетом ожидающей брони...");
        $slots = $this->getSlots($resourceId, '2024-01-16', 8);
        $this->info("   📊 Доступные слоты: " . count($slots));

        // ШАГ 4: Подтверждение брони администратором
        $this->info("\n✅ ШАГ 4: Подтверждение брони администратором...");
        $confirmedBooking = $this->confirmBooking($userBooking['id']);
        $this->checkStatus($confirmedBooking, 'confirmed', "Бронь подтверждена администратором");

        // ШАГ 5: Попытка отмены просроченной брони (должна быть ошибка)
        $this->info("\n❌ ШАГ 5: Попытка поздней отмены...");
        try {
            $pastBooking = $this->createBooking([
                'resource_id' => $resourceId,
                'start' => '2024-01-10 10:00:00',
                'end' => '2024-01-10 11:00:00',
                'is_admin' => true,
                'booker' => ['name' => 'Тест отмены']
            ]);

            $this->cancelBooking($pastBooking['id'], 'client', 'Поздняя отмена');
            $this->error("   🚨 НЕОЖИДАННО: Должно было быть ошибкой для поздней отмены!");
        } catch (\Exception $e) {
            $this->info("   ✅ Ожидаемая ошибка: {$e->getMessage()}");
        }

        $this->info("\n🎉 СЦЕНАРИЙ 2 ЗАВЕРШЕН: Динамические слоты и ручное подтверждение работают корректно!");
    }

    /**
     * ===========================================================================
     * СЦЕНАРИЙ 3: Групповая тренировка - Фиксированные слоты + групповые брони
     * ===========================================================================
     */
    private function runScenario3(array $setupData): void
    {
        $resourceId = $setupData['resource_id'];

        $this->info("\n🏋️ СЦЕНАРИЙ 3: ГРУППОВАЯ ТРЕНИРОВКА");
        $this->line("🎯 Цель: Демонстрация групповых броней с ограничением участников");
        $this->line("📋 Параметры: групповой ресурс, фиксированные слоты 90 мин, лимит 10 участников");

        // ШАГ 1: Получить доступные слоты для групповой тренировки
        $this->info("\n📅 ШАГ 1: Получение доступных слотов для групповой тренировки...");
        $slots = $this->getSlots($resourceId, '2024-01-17', 5);
        $this->info("   📊 Доступные слоты: " . count($slots));

        // ШАГ 2: Создать групповую бронь с организатором
        $this->info("\n👥 ШАГ 2: Создание групповой брони с организатором...");
        $groupBooking = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => '2024-01-17 10:00:00',
            'end' => '2024-01-17 11:30:00',
            'booker' => [
                'name' => 'Организатор тренировки',
                'email' => 'organizer@example.com',
                'type' => 'client',
                'metadata' => ['is_organizer' => true]
            ]
        ]);
        $this->checkStatus($groupBooking, 'confirmed', "Групповая бронь создана");

        // ШАГ 3: Добавить дополнительных участников к брони
        $this->info("\n👥 ШАГ 3: Добавление участников в групповую бронь...");
        $this->addParticipantsToBooking($groupBooking['id'], [
            ['name' => 'Участник 1', 'email' => 'user1@example.com'],
            ['name' => 'Участник 2', 'email' => 'user2@example.com'],
            ['name' => 'Участник 3', 'email' => 'user3@example.com'],
        ]);

        // ШАГ 4: Попытка превысить лимит участников (должна быть ошибка)
        $this->info("\n❌ ШАГ 4: Попытка превысить лимит участников...");
        try {
            $this->addParticipantsToBooking($groupBooking['id'], [
                ['name' => 'Лишний участник', 'email' => 'extra@example.com'],
            ]);
            $this->error("   🚨 НЕОЖИДАННО: Должно было быть ошибкой!");
        } catch (\Exception $e) {
            $this->info("   ✅ Ожидаемая ошибка: {$e->getMessage()}");
        }

        // ШАГ 5: Проверка доступности после групповой брони
        $this->info("\n📅 ШАГ 5: Проверка доступности слотов после групповой брони...");
        $updatedSlots = $this->getSlots($resourceId, '2024-01-17', 5);
        $this->info("   📊 Доступные слоты после брони: " . count($updatedSlots));

        $this->info("\n🎉 СЦЕНАРИЙ 3 ЗАВЕРШЕН: Групповые брони и лимиты участников работают корректно!");
    }

    /**
     * ===========================================================================
     * СЦЕНАРИЙ 4: Дорогое оборудование - Динамические слоты + строгие ограничения
     * ===========================================================================
     */
    private function runScenario4(array $setupData): void
    {
        $resourceId = $setupData['resource_id'];

        $this->info("\n💎 СЦЕНАРИЙ 4: ДОРОГОЕ ОБОРУДОВАНИЕ");
        $this->line("🎯 Цель: Демонстрация строгих ограничений для ценных ресурсов");
        $this->line("📋 Параметры: строгие ограничения, динамические слоты 120 мин, подтверждение обязательно");

        // ШАГ 1: Попытка брони без достаточного времени (должна быть ошибка)
        $this->info("\n❌ ШАГ 1: Попытка брони без достаточного времени...");
        try {
            $this->createBooking([
                'resource_id' => $resourceId,
                'start' => now()->addMinutes(30)->format('Y-m-d H:i:s'),
                'end' => now()->addMinutes(150)->format('Y-m-d H:i:s'),
                'booker' => ['name' => 'Торопливый клиент']
            ]);
            $this->error("   🚨 НЕОЖИДАННО: Должно было быть ошибкой!");
        } catch (\Exception $e) {
            $this->info("   ✅ Ожидаемая ошибка: {$e->getMessage()}");
        }

        // ШАГ 2: Корректная бронь с ожиданием подтверждения
        $this->info("\n⏳ ШАГ 2: Корректная бронь с ожиданием подтверждения...");
        $pendingBooking = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => '2024-01-18 10:00:00',
            'end' => '2024-01-18 12:00:00',
            'booker' => ['name' => 'Серьезный клиент', 'email' => 'serious@example.com']
        ]);
        $this->checkStatus($pendingBooking, 'pending', "Бронь ожидает подтверждения");

        // ШАГ 3: Отклонение брони администратором
        $this->info("\n❌ ШАГ 3: Отклонение брони администратором...");
        $rejectedBooking = $this->cancelBooking($pendingBooking['id'], 'admin', 'Оборудование на обслуживании');
        $this->checkStatus($rejectedBooking, 'cancelled_by_admin', "Бронь отклонена администратором");

        // ШАГ 4: Бронь администратором с обходом ограничений
        $this->info("\n👨‍💼 ШАГ 4: Бронь администратором с обходом ограничений...");
        $adminBooking = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => now()->addMinutes(60)->format('Y-m-d H:i:s'),
            'end' => now()->addMinutes(180)->format('Y-m-d H:i:s'),
            'is_admin' => true,
            'booker' => ['name' => 'Администратор', 'type' => 'admin']
        ]);
        $this->checkStatus($adminBooking, 'confirmed', "Бронь администратора подтверждена");

        // ШАГ 5: Попытка отмены в последний момент (должна быть ошибка)
        $this->info("\n❌ ШАГ 5: Попытка отмены в последний момент...");
        try {
            $this->cancelBooking($adminBooking['id'], 'client', 'Срочные обстоятельства');
            $this->error("   🚨 НЕОЖИДАННО: Должно было быть ошибкой!");
        } catch (\Exception $e) {
            $this->info("   ✅ Ожидаемая ошибка: {$e->getMessage()}");
        }

        $this->info("\n🎉 СЦЕНАРИЙ 4 ЗАВЕРШЕН: Строгие ограничения для ценных ресурсов работают корректно!");
    }

    /**
     * ===========================================================================
     * СЦЕНАРИЙ 5: Гостиничный номер - Переходящие брони + разные стратегии
     * ===========================================================================
     */
    private function runScenario5(array $setupData): void
    {
        $resourceId = $setupData['resource_id'];

        $this->info("\n🏨 СЦЕНАРИЙ 5: ГОСТИНИЧНЫЙ НОМЕР");
        $this->line("🎯 Цель: Демонстрация многодневных (переходящих) броней");
        $this->line("📋 Параметры: переходящие брони, многодневные, фиксированные слоты 24 часа");

        // ШАГ 1: Бронь на 3 дня
        $this->info("\n📅 ШАГ 1: Бронь номера на 3 дня...");
        $threeDayBooking = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => '2024-01-20 14:00:00',
            'end' => '2024-01-23 12:00:00',
            'booker' => ['name' => 'Гость отеля', 'email' => 'guest@example.com']
        ]);
        $this->checkStatus($threeDayBooking, 'confirmed', "Бронь на 3 дня создана");

        // ШАГ 2: Попытка брони в пересекающиеся даты (должна быть ошибка)
        $this->info("\n❌ ШАГ 2: Попытка брони в пересекающиеся даты...");
        try {
            $this->createBooking([
                'resource_id' => $resourceId,
                'start' => '2024-01-22 10:00:00', // Пересекается с существующей бронью
                'end' => '2024-01-24 12:00:00',
                'booker' => ['name' => 'Конфликтный гость']
            ]);
            $this->error("   🚨 НЕОЖИДАННО: Должно было быть ошибкой!");
        } catch (\Exception $e) {
            $this->info("   ✅ Ожидаемая ошибка: {$e->getMessage()}");
        }

        // ШАГ 3: Бронь сразу после освобождения номера
        $this->info("\n✅ ШАГ 3: Бронь сразу после освобождения номера...");
        $nextBooking = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => '2024-01-23 14:00:00', // После предыдущей брони
            'end' => '2024-01-25 12:00:00',
            'booker' => ['name' => 'Следующий гость']
        ]);
        $this->checkStatus($nextBooking, 'confirmed', "Бронь после освобождения создана");

        // ШАГ 4: Проверка доступности в диапазоне дат
        $this->info("\n📅 ШАГ 4: Проверка доступности в диапазоне дат...");
        $this->testDateRangeAvailability($resourceId);

        // ШАГ 5: Перенос длительной брони администратором
        $this->info("\n🔄 ШАГ 5: Перенос длительной брони администратором...");
        $rescheduled = $this->rescheduleBooking($threeDayBooking['id'],
            '2024-01-25 14:00:00', '2024-01-28 12:00:00', 'admin');
        $this->info("   ✅ Длительная бронь перенесена: {$rescheduled['start']} → {$rescheduled['end']}");

        $this->info("\n🎉 СЦЕНАРИЙ 5 ЗАВЕРШЕН: Многодневные брони работают корректно!");
    }

    /**
     * ===========================================================================
     * СЦЕНАРИЙ 6: Экстренный случай - Администратор vs Пользователь
     * ===========================================================================
     */
    private function runScenario6(array $setupData): void
    {
        $resourceId = $setupData['resource_id'];

        $this->info("\n⚡ СЦЕНАРИЙ 6: ЭКСТРЕННЫЙ СЛУЧАЙ");
        $this->line("🎯 Цель: Демонстрация приоритета администратора над пользователем");
        $this->line("📋 Параметры: приоритет администратора, экстренные отмены, перепланирование");

        // ШАГ 1: Пользователь создает обычную бронь
        $this->info("\n👤 ШАГ 1: Пользователь создает обычную бронь...");
        $userBooking = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => '2024-01-19 15:00:00',
            'end' => '2024-01-19 16:00:00',
            'booker' => ['name' => 'Обычный пользователь']
        ]);
        $this->checkStatus($userBooking, 'confirmed', "Бронь пользователя создана");

        // ШАГ 2: Администратор создает экстренную бронь поверх существующей
        $this->info("\n👨‍💼 ШАГ 2: Администратор создает экстренную бронь...");
        $emergencyBooking = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => '2024-01-19 15:00:00', // То же время что и у пользователя
            'end' => '2024-01-19 16:00:00',
            'is_admin' => true,
            'booker' => ['name' => 'Администратор', 'type' => 'admin']
        ]);
        $this->checkStatus($emergencyBooking, 'confirmed', "Экстренная бронь администратора создана");

        // ШАГ 3: Проверка что пользовательская бронь была автоматически отменена
        $this->info("\n🔍 ШАГ 3: Проверка статуса пользовательской брони...");
        $this->line("   Цель: Убедиться что пользовательская бронь автоматически отменена");
        $updatedUserBooking = $this->getBooking($userBooking['id']);
        $this->checkStatus($updatedUserBooking, 'cancelled_by_admin', "Бронь пользователя автоматически отменена");

        // ШАГ 4: Администратор переносит экстренную бронь
        $this->info("\n🔄 ШАГ 4: Администратор переносит экстренную бронь...");
        $rescheduledEmergency = $this->rescheduleBooking($emergencyBooking['id'],
            '2024-01-19 16:00:00', '2024-01-19 17:00:00', 'admin');
        $this->info("   ✅ Экстренная бронь перенесена: {$rescheduledEmergency['start']} → {$rescheduledEmergency['end']}");

        // ШАГ 5: Восстановление пользовательской брони на освободившееся время
        $this->info("\n✅ ШАГ 5: Восстановление пользовательской брони...");
        $restoredBooking = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => '2024-01-19 15:00:00', // Освободившееся время
            'end' => '2024-01-19 16:00:00',
            'booker' => ['name' => 'Обычный пользователь']
        ]);
        $this->checkStatus($restoredBooking, 'confirmed', "Бронь пользователя восстановлена");

        $this->info("\n🎉 СЦЕНАРИЙ 6 ЗАВЕРШЕН: Приоритет администратора работает корректно!");
    }

    /**
     * ===========================================================================
     * СЦЕНАРИЙ 7: Салон красоты - Статическое расписание с праздниками
     * ===========================================================================
     */
    private function runScenario7(array $setupData): void
    {
        $resourceId = $setupData['resource_id'];

        $this->info("\n💅 СЦЕНАРИЙ 7: САЛОН КРАСОТЫ");
        $this->line("🎯 Цель: Демонстрация работы с праздничными днями и выходными");
        $this->line("📋 Параметры: Статическое расписание с праздниками, фиксированные слоты");

        // Тестирование разных типов дней: рабочие, праздничные, выходные
        $testDates = [
            '2024-01-15' => ['type' => 'working', 'desc' => 'Рабочий понедельник'],
            '2024-01-01' => ['type' => 'holiday', 'desc' => 'Праздник (Новый год)'],
            '2024-01-14' => ['type' => 'weekend', 'desc' => 'Воскресенье (выходной)'],
            '2024-03-08' => ['type' => 'holiday', 'desc' => 'Праздник (8 марта)'],
            '2024-01-16' => ['type' => 'working', 'desc' => 'Рабочий вторник']
        ];

        foreach ($testDates as $date => $info) {
            $this->info("\n📅 Проверка {$info['desc']} ({$date})...");
            $slots = $this->getSlots($resourceId, $date, 3);

            if ($info['type'] === 'working' && count($slots) > 0) {
                $this->info("   ✅ {$info['desc']}: " . count($slots) . " слотов доступно");
                $this->line("      🕒 Первые слоты: " . implode(', ', array_slice($slots, 0, 2)));
            } elseif ($info['type'] === 'working') {
                $this->error("   ❌ {$info['desc']}: Нет доступных слотов (НЕОЖИДАННО)");
            } else {
                $this->info("   ✅ {$info['desc']}: Нет слотов (ожидаемо)");
            }
        }

        // Тестирование обработки перерывов в рабочий день
        $this->info("\n⏰ Тестирование обработки перерывов...");
        $slotsMonday = $this->getSlots($resourceId, '2024-01-15', 10);
        $hasBreakGap = false;

        foreach ($slotsMonday as $slot) {
            if (strpos($slot, '13:00') !== false) {
                $hasBreakGap = true;
                break;
            }
        }

        if ($hasBreakGap) {
            $this->info("   ✅ Перерывы правильно исключены из слотов");
        } else {
            $this->error("   ❌ Перерывы неправильно обработаны");
        }

        $this->info("\n🎉 СЦЕНАРИЙ 7 ЗАВЕРШЕН: Обработка праздников и перерывов работает корректно!");
    }

    /**
     * ===========================================================================
     * СЦЕНАРИЙ 8: Бизнес-центр - Смешанное расписание + перерывы
     * ===========================================================================
     */
    private function runScenario8(array $setupData): void
    {
        $resourceId = $setupData['resource_id'];

        $this->info("\n🏢 СЦЕНАРИЙ 8: БИЗНЕС-ЦЕНТР");
        $this->line("🎯 Цель: Демонстрация работы со сложным расписанием с множественными перерывами");
        $this->line("📋 Параметры: Сложное расписание с множественными перерывами, динамические слоты");

        // ШАГ 1: Получить слоты в день со сложным расписанием
        $this->info("\n📅 ШАГ 1: Получение слотов в день со сложным расписанием...");
        $slots = $this->getSlots($resourceId, '2024-01-22', 10);
        $this->info("   📊 Доступные слоты: " . count($slots));
        $this->info("   🕒 Примеры слотов: " . implode(', ', array_slice($slots, 0, 5)));

        // ШАГ 2: Создать бронь между перерывами
        $this->info("\n✅ ШАГ 2: Создание брони между перерывами...");
        $betweenBreaksBooking = $this->createBooking([
            'resource_id' => $resourceId,
            'start' => '2024-01-22 13:30:00', // Между обедом и кофе-брейком
            'end' => '2024-01-22 15:00:00',
            'booker' => ['name' => 'Бизнес-встреча']
        ]);
        $this->checkStatus($betweenBreaksBooking, 'pending', "Бронь между перерывами создана");

        // ШАГ 3: Подтверждение брони администратором
        $this->info("\n✅ ШАГ 3: Подтверждение брони администратором...");
        $confirmedBooking = $this->confirmBooking($betweenBreaksBooking['id']);
        $this->checkStatus($confirmedBooking, 'confirmed', "Бронь подтверждена");

        // ШАГ 4: Попытка брони через несколько перерывов
        $this->info("\n🔍 ШАГ 4: Попытка брони через несколько перерывов...");
        try {
            $crossBreaksBooking = $this->createBooking([
                'resource_id' => $resourceId,
                'start' => '2024-01-22 11:30:00', // До обеда
                'end' => '2024-01-22 17:00:00',   // После кофе-брейка
                'booker' => ['name' => 'Длительная встреча']
            ]);
            $this->info("   ✅ Длительная бронь создана: {$crossBreaksBooking['start']} - {$crossBreaksBooking['end']}");
        } catch (\Exception $e) {
            $this->info("   ❌ Ошибка: {$e->getMessage()}");
        }

        // ШАГ 5: Проверка доступности в праздничный день
        $this->info("\n🎄 ШАГ 5: Проверка доступности в праздничный день...");
        $holidaySlots = $this->getSlots($resourceId, '2024-01-01', 5); // Новый год
        if (count($holidaySlots) === 0) {
            $this->info("   ✅ В праздничный день слотов нет (ожидаемо)");
        } else {
            $this->error("   ❌ В праздничный день есть слоты (НЕОЖИДАННО)");
        }

        $this->info("\n🎉 СЦЕНАРИЙ 8 ЗАВЕРШЕН: Сложное расписание с множественными перерывами работает корректно!");
    }

    // ===========================================================================
    // ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ ДЛЯ ТЕСТИРОВАНИЯ
    // ===========================================================================

    /**
     * Тестирование пограничных случаев относительно перерывов
     */
    private function testBoundaryCases(int $resourceId): void
    {
        $this->line("   🎯 Тестирование различных временных диапазонов относительно перерыва:");

        $resource = Resource::find($resourceId);

        $testCases = [
            [
                'start' => '2024-01-15 13:00:00',
                'end' => '2024-01-15 14:00:00',
                'expected' => false,
                'reason' => 'Полностью внутри перерыва (13:15-14:15)'
            ],
            [
                'start' => '2024-01-15 12:30:00',
                'end' => '2024-01-15 13:30:00',
                'expected' => false,
                'reason' => 'Начинается до (12:30), заканчивается во время перерыва (13:30)'
            ],
            [
                'start' => '2024-01-15 13:45:00',
                'end' => '2024-01-15 14:45:00',
                'expected' => false,
                'reason' => 'Начинается во время перерыва (13:45), заканчивается после (14:45)'
            ],
            [
                'start' => '2024-01-15 14:15:00',
                'end' => '2024-01-15 15:15:00',
                'expected' => true,
                'reason' => 'Корректный слот после перерыва (14:15)'
            ],
            [
                'start' => '2024-01-15 11:00:00',
                'end' => '2024-01-15 12:00:00',
                'expected' => true,
                'reason' => 'Корректный слот до перерыва (11:00-12:00)'
            ],
            [
                'start' => '2024-01-15 12:00:00',
                'end' => '2024-01-15 13:15:00',
                'expected' => true,
                'reason' => 'Заканчивается точно в начале перерыва (13:15)'
            ],
            [
                'start' => '2024-01-15 14:15:00',
                'end' => '2024-01-15 14:15:00',
                'expected' => true,
                'reason' => 'Начинается точно в конце перерыва (14:15)'
            ],
        ];

        foreach ($testCases as $case) {
            try {
                $startTime = Carbon::parse($case['start']);
                $endTime = Carbon::parse($case['end']);

                // Используем bookingService для проверки
                $available = $this->bookingService->isTimeRangeAvailable($resource, $startTime, $endTime);

                $status = $available === $case['expected'] ? '✅' : '❌';
                $result = $available ? 'доступен' : 'недоступен';
                $this->info("   {$status} {$case['reason']}: {$result}");

                // Если результат не совпадает с ожиданием, покажем дополнительную информацию
                if ($available !== $case['expected']) {
                    $this->warn("      Ожидалось: " . ($case['expected'] ? 'доступен' : 'недоступен'));

                    // Детальная диагностика
                    $rangeAvailable = $this->bookingService->isRangeAvailable($resource, $startTime, $endTime);
                    $breaksAvailable = $this->bookingService->isTimeAvailableConsideringBreaks($resource, $startTime, $endTime);
                    $this->warn("      Диагностика - Бронирования: " . ($rangeAvailable ? 'нет' : 'есть') .
                        ", Перерывы: " . ($breaksAvailable ? 'нет' : 'есть'));
                }
            } catch (\Exception $e) {
                $this->info("   ❌ {$case['reason']}: ошибка - {$e->getMessage()}");
            }
        }
    }



    /**
     * Тестирование доступности в диапазоне дат для многодневных броней
     */
    private function testDateRangeAvailability(int $resourceId): void
    {
        $this->line("   🎯 Тестирование доступности различных диапазонов дат:");

        $testRanges = [
            ['start' => '2024-01-21 14:00:00', 'end' => '2024-01-22 12:00:00', 'expected' => false, 'reason' => 'Пересекается с существующей бронью'],
            ['start' => '2024-01-19 14:00:00', 'end' => '2024-01-20 12:00:00', 'expected' => true, 'reason' => 'До существующей брони'],
            ['start' => '2024-01-25 14:00:00', 'end' => '2024-01-26 12:00:00', 'expected' => true, 'reason' => 'После существующей брони'],
        ];

        foreach ($testRanges as $range) {
            $available = $this->isRangeAvailable($resourceId, $range['start'], $range['end']);
            $status = $available === $range['expected'] ? '✅' : '❌';
            $this->info("   {$status} {$range['reason']}: " . ($available ? 'доступен' : 'недоступен'));
        }
    }

    /**
     * Добавление участников в групповую бронь (симуляция)
     */
    private function addParticipantsToBooking(int $bookingId, array $participants): void
    {
        $this->line("   👥 Добавление участников в бронь {$bookingId}:");

        foreach ($participants as $participant) {
            // В реальной системе здесь был бы вызов API для добавления участников
            $this->info("      👤 Добавлен участник: {$participant['name']}");
        }
        $this->info("   ✅ Участники добавлены в бронь {$bookingId}");
    }

    // ===========================================================================
    // ОСНОВНЫЕ МЕТОДЫ ДЛЯ РАБОТЫ С БРОНИРОВАНИЯМИ (ПРЯМЫЕ ВЫЗОВЫ)
    // ===========================================================================

    /**
     * Получение доступных слотов для ресурса
     */
    private function getSlots(int $resourceId, string $date, int $count): array
    {
        try {
            $request = new GetSlotsRequest();
            $request->merge([
                'date' => $date,
                'count' => $count,
                'only_today' => true
            ]);

            $response = $this->bookingController->getAvailableSlots($resourceId, $request);
            $data = $response->getData(true);

            if (isset($data['data'])) {
                return array_map(function($slot) {
                    return $slot['start'] . '-' . $slot['end'];
                }, $data['data']);
            }

            return ["10:00-11:00", "11:00-12:00", "14:00-15:00"]; // Fallback для демо
        } catch (\Exception $e) {
            $this->warn("   ⚠️ Ошибка получения слотов: {$e->getMessage()}");
            return ["10:00-11:00", "11:00-12:00", "14:00-15:00"]; // Fallback для демо
        }
    }

    /**
     * Создание новой брони
     */
    private function createBooking(array $data): array
    {
        $request = new CreateBookingRequest();
        $request->merge($data);

        $response = $this->bookingController->createBooking($request);
        $responseData = $response->getData(true);

        if (isset($responseData['data'])) {
            return $responseData['data'];
        }

        throw new \Exception($responseData['error'] ?? 'Ошибка создания брони');
    }

    /**
     * Подтверждение брони
     */
    private function confirmBooking(int $bookingId): array
    {
        $response = $this->bookingController->confirmBooking($bookingId);
        $responseData = $response->getData(true);

        return $responseData['data'];
    }

    /**
     * Отмена брони
     */
    private function cancelBooking(int $bookingId, string $cancelledBy, ?string $reason = null): array
    {
        $request = new CancelBookingRequest();
        $request->merge([
            'cancelled_by' => $cancelledBy,
            'reason' => $reason
        ]);

        $response = $this->bookingController->cancelBooking($bookingId, $request);
        $responseData = $response->getData(true);

        return $responseData['data'];
    }

    /**
     * Перенос брони
     */
    private function rescheduleBooking(int $bookingId, string $newStart, string $newEnd, string $requestedBy): array
    {
        $request = new RescheduleBookingRequest();
        $request->merge([
            'new_start' => $newStart,
            'new_end' => $newEnd,
            'requested_by' => $requestedBy
        ]);

        $response = $this->bookingController->rescheduleBooking($bookingId, $request);
        $responseData = $response->getData(true);

        return $responseData['data'];
    }

    /**
     * Проверка доступности временного диапазона
     */
    private function isRangeAvailable(int $resourceId, string $start, string $end): bool
    {
        $resource = Resource::find($resourceId);
        $startTime = Carbon::parse($start);
        $endTime = Carbon::parse($end);

        // Используем bookingService для проверки
        return $this->bookingService->isTimeRangeAvailable($resource, $startTime, $endTime);
    }

    /**
     * Получение информации о брони по ID
     */
    private function getBooking(int $bookingId): array
    {
        // Для получения брони создаем простой Request
        $request = new Request();

        // В реальном контроллере может быть метод show, но если его нет,
        // используем прямой запрос к модели
        try {
            $booking = \App\Models\Booking::with(['resource', 'bookers'])->findOrFail($bookingId);
            return [
                'id' => $booking->id,
                'resource_id' => $booking->resource_id,
                'start' => $booking->start,
                'end' => $booking->end,
                'status' => $booking->status,
                'reason' => $booking->reason,
                'resource' => $booking->resource,
                'bookers' => $booking->bookers
            ];
        } catch (\Exception $e) {
            throw new \Exception('Бронь не найдена: ' . $e->getMessage());
        }
    }

    /**
     * Проверка статуса брони
     */
    private function checkStatus(array $booking, string $expectedStatus, string $message): void
    {
        if ($booking['status'] === $expectedStatus) {
            $this->info("   ✅ {$message}: статус = {$booking['status']}");
        } else {
            $this->error("   ❌ {$message}: ожидался {$expectedStatus}, получен {$booking['status']}");
        }
    }

    // ===========================================================================
    // МЕТОДЫ ДЛЯ ПОЛУЧЕНИЯ ДАННЫХ СЦЕНАРИЕВ (без изменений)
    // ===========================================================================

    /**
     * Получение данных расписания для конкретного сценария
     */
    private function getTimetableForScenario(int $scenarioId): array
    {
        $timetables = [
            1 => [ // Парикмахерская (усложненный)
                'type' => 'static',
                'schedule' => [
                    'days' => [
                        'monday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '18:00'],
                            'breaks' => [['start' => '13:15', 'end' => '14:15']] // Нестандартный перерыв
                        ],
                        'tuesday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '18:00'],
                            'breaks' => [['start' => '13:15', 'end' => '14:15']]
                        ],
                        'wednesday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '18:00'],
                            'breaks' => [['start' => '13:15', 'end' => '14:15']]
                        ],
                        'thursday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '18:00'],
                            'breaks' => [['start' => '13:15', 'end' => '14:15']]
                        ],
                        'friday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '18:00'],
                            'breaks' => [['start' => '13:15', 'end' => '14:15']]
                        ]
                    ]
                ]
            ],
            2 => [ // Переговорная комната
                'type' => 'static',
                'schedule' => [
                    'days' => [
                        'monday' => ['working_hours' => ['start' => '08:00', 'end' => '20:00']],
                        'tuesday' => ['working_hours' => ['start' => '08:00', 'end' => '20:00']],
                        'wednesday' => ['working_hours' => ['start' => '08:00', 'end' => '20:00']],
                        'thursday' => ['working_hours' => ['start' => '08:00', 'end' => '20:00']],
                        'friday' => ['working_hours' => ['start' => '08:00', 'end' => '18:00']],
                    ]
                ]
            ],
            3 => [ // Групповая тренировка
                'type' => 'static',
                'schedule' => [
                    'days' => [
                        'monday' => ['working_hours' => ['start' => '07:00', 'end' => '22:00']],
                        'tuesday' => ['working_hours' => ['start' => '07:00', 'end' => '22:00']],
                        'wednesday' => ['working_hours' => ['start' => '07:00', 'end' => '22:00']],
                        'thursday' => ['working_hours' => ['start' => '07:00', 'end' => '22:00']],
                        'friday' => ['working_hours' => ['start' => '07:00', 'end' => '22:00']],
                        'saturday' => ['working_hours' => ['start' => '09:00', 'end' => '18:00']],
                        'sunday' => ['working_hours' => ['start' => '09:00', 'end' => '16:00']],
                    ]
                ]
            ],
            4 => [ // Дорогое оборудование
                'type' => 'static',
                'schedule' => [
                    'days' => [
                        'monday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '18:00'],
                            'breaks' => [['start' => '12:30', 'end' => '13:30']] // Обеденный перерыв
                        ],
                        'tuesday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '18:00'],
                            'breaks' => [['start' => '12:30', 'end' => '13:30']]
                        ],
                        'wednesday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '18:00'],
                            'breaks' => [['start' => '12:30', 'end' => '13:30']]
                        ],
                        'thursday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '18:00'],
                            'breaks' => [['start' => '12:30', 'end' => '13:30']]
                        ],
                        'friday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '18:00'],
                            'breaks' => [['start' => '12:30', 'end' => '13:30']]
                        ],
                    ]
                ]
            ],
            5 => [ // Гостиничный номер
                'type' => 'static',
                'schedule' => [
                    'days' => [
                        'monday' => ['working_hours' => ['start' => '00:00', 'end' => '23:59']],
                        'tuesday' => ['working_hours' => ['start' => '00:00', 'end' => '23:59']],
                        'wednesday' => ['working_hours' => ['start' => '00:00', 'end' => '23:59']],
                        'thursday' => ['working_hours' => ['start' => '00:00', 'end' => '23:59']],
                        'friday' => ['working_hours' => ['start' => '00:00', 'end' => '23:59']],
                        'saturday' => ['working_hours' => ['start' => '00:00', 'end' => '23:59']],
                        'sunday' => ['working_hours' => ['start' => '00:00', 'end' => '23:59']],
                    ]
                ]
            ],
            6 => [ // Экстренный случай
                'type' => 'static',
                'schedule' => [
                    'days' => [
                        'monday' => ['working_hours' => ['start' => '08:00', 'end' => '20:00']],
                        'tuesday' => ['working_hours' => ['start' => '08:00', 'end' => '20:00']],
                        'wednesday' => ['working_hours' => ['start' => '08:00', 'end' => '20:00']],
                        'thursday' => ['working_hours' => ['start' => '08:00', 'end' => '20:00']],
                        'friday' => ['working_hours' => ['start' => '08:00', 'end' => '20:00']],
                    ]
                ]
            ],
            7 => [ // Салон красоты с праздниками
                'type' => 'static',
                'schedule' => [
                    'days' => [
                        'monday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '20:00'],
                            'breaks' => [['start' => '13:15', 'end' => '14:15']] // Нестандартный перерыв
                        ],
                        'tuesday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '20:00'],
                            'breaks' => [['start' => '13:15', 'end' => '14:15']]
                        ],
                        'wednesday' => [
                            'working_hours' => ['start' => '10:00', 'end' => '18:00'],
                            'breaks' => [['start' => '14:00', 'end' => '15:00']]
                        ],
                        'thursday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '20:00'],
                            'breaks' => [['start' => '13:15', 'end' => '14:15']]
                        ],
                        'friday' => [
                            'working_hours' => ['start' => '09:00', 'end' => '21:00'],
                            'breaks' => [['start' => '13:15', 'end' => '14:15']]
                        ],
                        'saturday' => [
                            'working_hours' => ['start' => '10:00', 'end' => '16:00'],
                            'breaks' => [['start' => '13:15', 'end' => '14:15']]
                        ]
                    ],
                    'holidays' => ['01-01', '01-02', '01-07', '03-08', '05-01', '05-09']
                ]
            ],
            8 => [ // Бизнес-центр со сложным расписанием
                'type' => 'static',
                'schedule' => [
                    'days' => [
                        'monday' => [
                            'working_hours' => ['start' => '08:00', 'end' => '22:00'],
                            'breaks' => [
                                ['start' => '12:15', 'end' => '13:15'], // Обеденный перерыв
                                ['start' => '16:00', 'end' => '16:30']  // Кофе-брейк
                            ]
                        ],
                        'tuesday' => [
                            'working_hours' => ['start' => '08:00', 'end' => '22:00'],
                            'breaks' => [
                                ['start' => '12:15', 'end' => '13:15'],
                                ['start' => '16:00', 'end' => '16:30']
                            ]
                        ],
                        'wednesday' => [
                            'working_hours' => ['start' => '08:00', 'end' => '22:00'],
                            'breaks' => [
                                ['start' => '12:15', 'end' => '13:15'],
                                ['start' => '16:00', 'end' => '16:30']
                            ]
                        ],
                        'thursday' => [
                            'working_hours' => ['start' => '08:00', 'end' => '22:00'],
                            'breaks' => [
                                ['start' => '12:15', 'end' => '13:15'],
                                ['start' => '16:00', 'end' => '16:30']
                            ]
                        ],
                        'friday' => [
                            'working_hours' => ['start' => '08:00', 'end' => '20:00'],
                            'breaks' => [
                                ['start' => '12:15', 'end' => '13:15'],
                                ['start' => '15:00', 'end' => '15:30']
                            ]
                        ],
                        'saturday' => [
                            'working_hours' => ['start' => '10:00', 'end' => '16:00'],
                            'breaks' => [['start' => '13:15', 'end' => '14:15']]
                        ]
                    ],
                    'holidays' => ['01-01', '01-02', '01-07', '02-23', '03-08', '05-01', '05-09', '06-12', '11-04']
                ]
            ]
        ];

        return $timetables[$scenarioId] ?? $timetables[1];
    }

    /**
     * Получение конфигурации ресурса для сценария
     */
    private function getResourceConfigForScenario(int $scenarioId): array
    {
        $configs = [
            1 => [ // Парикмахерская (усложненный)
                'require_confirmation' => false,           // Автоматическое подтверждение
                'slot_duration_minutes' => 60,            // Слоты по 60 минут
                'slot_strategy' => 'fixed',               // Фиксированные слоты
                'min_advance_time' => 60,                 // Бронирование минимум за 60 мин
                'cancellation_time' => 120,               // Отмена возможна за 120 мин
                'reschedule_time' => 240,                 // Перенос возможен за 240 мин
                'reminder_time' => 1440                   // Напоминание за 24 часа
            ],
            2 => [ // Переговорная
                'require_confirmation' => true,           // Ручное подтверждение
                'slot_duration_minutes' => 30,            // Слоты по 30 минут
                'slot_strategy' => 'dinamic',             // Динамические слоты
                'min_advance_time' => 1440,               // Бронирование за 24 часа
                'cancellation_time' => 720,               // Отмена за 12 часов
                'reschedule_time' => 1440                 // Перенос за 24 часа
            ],
            3 => [ // Групповая тренировка
                'require_confirmation' => false,          // Автоматическое подтверждение
                'slot_duration_minutes' => 90,            // Слоты по 90 минут
                'slot_strategy' => 'fixed',               // Фиксированные слоты
                'max_participants' => 10,                 // Максимум 10 участников
                'min_advance_time' => 60,                 // Бронирование за 60 мин
                'cancellation_time' => 180,               // Отмена за 3 часа
                'reschedule_time' => 360                  // Перенос за 6 часов
            ],
            4 => [ // Дорогое оборудование
                'require_confirmation' => true,           // Обязательное подтверждение
                'slot_duration_minutes' => 120,           // Слоты по 120 минут
                'slot_strategy' => 'dinamic',             // Динамические слоты
                'min_advance_time' => 2880,               // Бронирование за 48 часов
                'cancellation_time' => 4320,              // Отмена за 72 часа
                'reschedule_time' => 5760,                // Перенос за 96 часов
                'reminder_time' => 1440                   // Напоминание за 24 часа
            ],
            5 => [ // Гостиничный номер
                'require_confirmation' => false,          // Автоматическое подтверждение
                'slot_duration_minutes' => 1440,          // Слоты по 24 часа
                'slot_strategy' => 'fixed',               // Фиксированные слоты
                'min_advance_time' => 0,                  // Бронирование в любое время
                'cancellation_time' => 10080,             // Отмена за 7 дней
                'reschedule_time' => 10080                // Перенос за 7 дней
            ],
            6 => [ // Экстренный случай
                'require_confirmation' => true,           // Ручное подтверждение
                'slot_duration_minutes' => 60,            // Слоты по 60 минут
                'slot_strategy' => 'dinamic',             // Динамические слоты
                'min_advance_time' => 0,                  // Бронирование в любое время
                'cancellation_time' => 0,                 // Отмена в любое время
                'reschedule_time' => 0                    // Перенос в любое время
            ],
            7 => [ // Салон красоты
                'require_confirmation' => false,          // Автоматическое подтверждение
                'slot_duration_minutes' => 60,            // Слоты по 60 минут
                'slot_strategy' => 'fixed',               // Фиксированные слоты
                'min_advance_time' => 120,                // Бронирование за 2 часа
                'cancellation_time' => 180,               // Отмена за 3 часа
                'reschedule_time' => 360,                 // Перенос за 6 часов
                'reminder_time' => 1440                   // Напоминание за 24 часа
            ],
            8 => [ // Бизнес-центр
                'require_confirmation' => true,           // Ручное подтверждение
                'slot_duration_minutes' => 60,            // Слоты по 60 минут
                'slot_strategy' => 'dinamic',             // Динамические слоты
                'max_participants' => 20,                 // Максимум 20 участников
                'min_advance_time' => 1440,               // Бронирование за 24 часа
                'cancellation_time' => 720,               // Отмена за 12 часов
                'reschedule_time' => 1440                 // Перенос за 24 часа
            ]
        ];

        return $configs[$scenarioId] ?? $configs[1];
    }

    /**
     * Получение описания сценария
     */
    private function getScenarioDescription(int $scenarioId): string
    {
        $descriptions = [
            1 => "Парикмахерская услуга с фиксированными слотами и автоматическим подтверждением (усложненный с перерывами)",
            2 => "Переговорная комната с динамическими слотами и ручным подтверждением",
            3 => "Групповая тренировка с фиксированными слотами и ограничением участников",
            4 => "Дорогое оборудование с динамическими слотами и строгими ограничениями",
            5 => "Гостиничный номер с переходящими бронями на несколько дней",
            6 => "Экстренные случаи с приоритетом администратора",
            7 => "Салон красоты со статическим расписанием и учетом праздничных дней",
            8 => "Бизнес-центр со сложным расписанием и множественными перерывами"
        ];

        return $descriptions[$scenarioId] ?? "Демонстрационный сценарий {$scenarioId}";
    }

    /**
     * Получение имени ресурса для сценария
     */
    private function getResourceName(int $scenarioId): string
    {
        $names = [
            1 => "💈 Парикмахер (усложненный)",
            2 => "🏢 Переговорная комната",
            3 => "🏋️ Групповая тренировка",
            4 => "💎 Дорогое оборудование",
            5 => "🏨 Гостиничный номер",
            6 => "⚡ Экстренный ресурс",
            7 => "💅 Салон красоты",
            8 => "🏢 Бизнес-центр"
        ];

        return $names[$scenarioId] ?? "Ресурс {$scenarioId}";
    }

    /**
     * Получение опций ресурса для сценария
     */
    private function getResourceOptionsForScenario(int $scenarioId): array
    {
        $options = [
            1 => ['specialization' => 'Парикмахер', 'experience' => '5 лет'],
            2 => ['location' => 'Этаж 3', 'capacity' => 8, 'equipment' => ['projector', 'whiteboard']],
            3 => ['location' => 'Зал А', 'trainer' => 'Иван Петров', 'type' => 'Йога'],
            4 => ['name' => '3D принтер', 'model' => 'Ultimaker S5', 'value' => '250000 руб'],
            5 => ['room_number' => '404', 'type' => 'Стандарт', 'beds' => 2],
            6 => ['priority' => 'high', 'emergency_contact' => '+7-XXX-XXX-XX-XX'],
            7 => ['specialization' => 'Косметолог', 'services' => ['маникюр', 'педикюр']],
            8 => ['location' => 'Бизнес-центр "Сити"', 'floor' => '15', 'capacity' => 50]
        ];

        return $options[$scenarioId] ?? ['scenario_id' => $scenarioId, 'demo' => true];
    }

    /**
     * Получение переопределений конфигурации ресурса
     */
    private function getResourceOverridesForScenario(int $scenarioId): array
    {
        return [];
    }

    /**
     * Получение краткого описания конфигурации
     */
    private function getConfigSummary(array $config): string
    {
        $parts = [];
        if (isset($config['require_confirmation'])) {
            $parts[] = $config['require_confirmation'] ? 'подтверждение:ручное' : 'подтверждение:авто';
        }
        if (isset($config['slot_strategy'])) {
            $strategy = $config['slot_strategy'] === 'fixed' ? 'фиксированные' : 'динамические';
            $parts[] = "слоты:{$strategy}";
        }
        if (isset($config['slot_duration_minutes'])) {
            $parts[] = "длительность:{$config['slot_duration_minutes']}мин";
        }
        if (isset($config['max_participants'])) {
            $parts[] = "макс:{$config['max_participants']}";
        }

        return implode(', ', $parts);
    }

    /**
     * Очистка данных сценария
     */
    private function cleanupScenarioData(int $scenarioId): void
    {
        $companyId = $scenarioId * 100;
        Company::where('id', $companyId)->delete();
    }

    /**
     * Сохранение результатов сценария
     */
    private function storeScenarioResults(int $scenarioId, array $setupData): void
    {
        $filename = storage_path("app/demo/scenario_{$scenarioId}_results.json");

        $results = [
            'scenario_id' => $scenarioId,
            'company_id' => $setupData['company_id'],
            'resource_id' => $setupData['resource_id'],
            'timestamp' => now()->toISOString(),
            'description' => $this->getScenarioDescription($scenarioId),
            'config' => $this->getResourceConfigForScenario($scenarioId)
        ];

        if (!is_dir(dirname($filename))) {
            mkdir(dirname($filename), 0755, true);
        }

        file_put_contents($filename, json_encode($results, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE));
        $this->info("📄 Результаты сохранены в: {$filename}");
    }

    /**
     * Отладочная информация о расписании и перерывах
     */
    private function debugTimetableInfo(int $resourceId): void
    {
        $resource = Resource::find($resourceId);
        $timetable = $resource->getEffectiveTimetable();

        if (!$timetable) {
            $this->warn("   ⚠️ У ресурса нет расписания");
            return;
        }

        $this->info("   📅 Расписание ресурса {$resourceId}:");
        $this->info("      Тип: {$timetable->type}");

        if ($timetable->type === 'static' && isset($timetable->schedule['days']['monday'])) {
            $monday = $timetable->schedule['days']['monday'];
            $this->info("      Понедельник: {$monday['working_hours']['start']} - {$monday['working_hours']['end']}");

            if (isset($monday['breaks']) && count($monday['breaks']) > 0) {
                $this->info("      Перерывы:");
                foreach ($monday['breaks'] as $index => $break) {
                    $this->info("        {$index}. {$break['start']} - {$break['end']}");
                }
            } else {
                $this->info("      Перерывов нет");
            }
        }
    }

}



=== app/Console/Commands/GenerateStaticTimetable.php ===
<?php

namespace App\Console\Commands;

use App\Actions\CreateOrUpdateCompanyAction;
use App\Models\Timetable;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Storage;

class GenerateStaticTimetable extends Command
{
    protected $signature = 'timetable:generate-static {company_id}';
    protected $description = 'Generate static timetable with random parameters';

    public function handle(CreateOrUpdateCompanyAction $createOrUpdateCompanyAction): void
    {
        $companyId = $this->argument('company_id');

        // Создаем или получаем компанию
        $company = $createOrUpdateCompanyAction->execute($companyId);

        // Выбираем один из двух вариантов рабочих дней
        $workingDaysPattern = $this->selectWorkingDaysPattern();

        // Выбираем один из трех вариантов рабочего времени
        $workingHoursTemplate = $this->selectWorkingHoursTemplate();

        // Генерируем перерывы один раз для всего расписания
        $breaksTemplate = $this->generateBreaksTemplate($workingHoursTemplate['regular']);

        $schedule = ['days' => []];

        // Определяем все дни недели
        $allDays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];

        foreach ($allDays as $day) {
            // Проверяем, является ли день рабочим в выбранном паттерне
            if (in_array($day, $workingDaysPattern)) {
                // Определяем рабочие часы для дня
                if (in_array($day, ['friday', 'saturday'])) {
                    // Пятница и суббота - на час раньше
                    $workingHours = $workingHoursTemplate['early'];
                } else {
                    // Остальные рабочие дни - обычное время
                    $workingHours = $workingHoursTemplate['regular'];
                }

                $schedule['days'][$day] = [
                    'working_hours' => $workingHours,
                    'breaks' => $breaksTemplate,
                ];
            }
            // Нерабочие дни не добавляем в расписание
        }

        // Российские праздники
        $schedule['holidays'] = [
            '01-01', '01-02', '01-03', '01-04', '01-05', '01-06', '01-08', // Новогодние каникулы
            '01-07', // Рождество
            '02-23', // День защитника Отечества
            '03-08', // Международный женский день
            '05-01', // Праздник Весны и Труда
            '05-09', // День Победы
            '06-12', // День России
            '11-04', // День народного единства
        ];

        $timetable = Timetable::create([
            'company_id' => $companyId,
            'type' => 'static',
            'schedule' => $schedule,
        ]);

        // Сохраняем пример в файл
        Storage::put('exports/static_timetable_example.json', json_encode($schedule, JSON_PRETTY_PRINT));

        $this->info("Static timetable created successfully for company {$companyId}");
        $this->info("Working days pattern: " . implode(', ', $workingDaysPattern));
        $this->info("Working hours: {$workingHoursTemplate['regular']['start']} - {$workingHoursTemplate['regular']['end']}");
        $this->info("Breaks count: " . count($breaksTemplate));
        $this->info("Example saved to storage/app/exports/static_timetable_example.json");
    }

    /**
     * Выбирает паттерн рабочих дней
     */
    private function selectWorkingDaysPattern(): array
    {
        $patterns = [
            ['monday', 'wednesday', 'friday'],    // Пн, Ср, Пт
            ['tuesday', 'thursday', 'saturday'],  // Вт, Чт, Сб
        ];

        return $patterns[array_rand($patterns)];
    }

    /**
     * Выбирает шаблон рабочих часов
     */
    private function selectWorkingHoursTemplate(): array
    {
        $templates = [
            [
                'regular' => ['start' => '08:00', 'end' => '17:00'],
                'early' => ['start' => '08:00', 'end' => '16:00'] // На час раньше
            ],
            [
                'regular' => ['start' => '09:00', 'end' => '18:00'],
                'early' => ['start' => '09:00', 'end' => '17:00'] // На час раньше
            ],
            [
                'regular' => ['start' => '10:00', 'end' => '19:00'],
                'early' => ['start' => '10:00', 'end' => '18:00'] // На час раньше
            ]
        ];

        return $templates[array_rand($templates)];
    }

    /**
     * Генерирует шаблон перерывов для всего расписания
     */
    private function generateBreaksTemplate(array $workingHours): array
    {
        $breaks = [];

        // Парсим время начала и окончания
        $startHour = (int)explode(':', $workingHours['start'])[0];
        $endHour = (int)explode(':', $workingHours['end'])[0];

        // Определяем количество перерывов
        $breakCount = $this->getBreakCount();

        if ($breakCount === 0) {
            return $breaks;
        }

        if ($breakCount === 1) {
            // Один перерыв продолжительностью 60 минут
            $breakStart = $startHour + 3; // Не менее 3 часов после начала
            $maxBreakStart = $endHour - 4; // Не менее 3 часов до конца (60 мин перерыв + 3 часа работы)

            if ($breakStart <= $maxBreakStart) {
                $breakStart = rand($breakStart, $maxBreakStart);
                $breaks[] = [
                    'start' => sprintf('%02d:00', $breakStart),
                    'end' => sprintf('%02d:00', $breakStart + 1),
                ];
            }
        } else {
            // Два перерыва по 30 минут каждый
            $minGapBetweenBreaks = 3; // 3 часа между перерывами
            $minEdgeGap = 2.5; // 2.5 часа от краев

            $firstBreakStart = $startHour + $minEdgeGap;
            $secondBreakEnd = $endHour - $minEdgeGap;

            // Проверяем, достаточно ли времени для двух перерывов
            $availableTime = $secondBreakEnd - $firstBreakStart - 1; // 1 час на оба перерыва
            if ($availableTime >= $minGapBetweenBreaks) {
                $firstBreakStart = rand(
                    (int)$firstBreakStart,
                    (int)($secondBreakEnd - $minGapBetweenBreaks - 1)
                );

                $secondBreakStart = $firstBreakStart + 0.5 + $minGapBetweenBreaks; // 30 мин первый перерыв + 3 часа
                $secondBreakStart = min($secondBreakStart, $endHour - $minEdgeGap - 0.5);

                if ($secondBreakStart <= $endHour - $minEdgeGap - 0.5) {
                    $breaks[] = [
                        'start' => sprintf('%02d:00', $firstBreakStart),
                        'end' => sprintf('%02d:30', $firstBreakStart),
                    ];
                    $breaks[] = [
                        'start' => sprintf('%02d:00', $secondBreakStart),
                        'end' => sprintf('%02d:30', $secondBreakStart),
                    ];
                }
            }
        }

        return $breaks;
    }

    /**
     * Определяет количество перерывов с заданными вероятностями
     */
    private function getBreakCount(): int
    {
        $random = rand(1, 100);

        if ($random <= 40) {
            return 1;
        } else {
            return 2;
        }
    }
}



=== app/Actions/UpdateTimetableAction.php ===
<?php

namespace App\Actions;

use App\Models\Timetable;
use Illuminate\Support\Facades\Storage;

class UpdateTimetableAction
{
    public function execute(Timetable $timetable, array $data): Timetable
    {
        if (isset($data['schedule'])) {
            // Сохраняем обновленный файл расписания
            $filename = 'timetable_' . $timetable->id . '_' . time() . '.json';
            Storage::put('imports/' . $filename, json_encode($data['schedule']));
        }

        $timetable->update($data);

        return $timetable;
    }
}



=== app/Actions/StoreTimetableAction.php ===
<?php

namespace App\Actions;

use App\Models\Timetable;
use Illuminate\Support\Facades\Storage;

class StoreTimetableAction
{
    public function execute(array $data): Timetable
    {
        // Сохраняем файл расписания
        $filename = 'timetable_' . time() . '.json';
        Storage::put('imports/' . $filename, json_encode($data['schedule']));

        $timetable = Timetable::create($data);

        return $timetable;
    }
}



=== app/Actions/ConfirmBookingAction.php ===
<?php

namespace App\Actions;

use App\Models\Booking;
use App\Enums\BookingStatus;

class ConfirmBookingAction
{
    public function execute(int $bookingId): Booking
    {
        $booking = Booking::findOrFail($bookingId);

        if ($booking->status !== BookingStatus::PENDING->value) {
            throw new \Exception('Можно подтверждать только брони в статусе ожидания');
        }

        $booking->status = BookingStatus::CONFIRMED->value;
        $booking->save();

        return $booking;
    }
}



=== app/Actions/CancelBookingAction.php ===
<?php

namespace App\Actions;

use App\Models\Booking;
use App\Enums\BookingStatus;
use App\ValueObjects\ResourceConfig;

class CancelBookingAction
{
    public function execute(int $bookingId, string $cancelledBy = 'client', ?string $reason = null): Booking
    {
        $booking = Booking::findOrFail($bookingId);
        $config = $booking->resource->getResourceConfig();

        if ($cancelledBy === 'client' && !$config->canCancel($booking->start)) {
            throw new \Exception('Время для отмены брони истекло');
        }

        $status = $cancelledBy === 'admin'
            ? BookingStatus::CANCELLED_BY_ADMIN
            : BookingStatus::CANCELLED_BY_CLIENT;

        $booking->update([
            'status' => $status->value,
            'reason' => $reason
        ]);

        return $booking;
    }
}



=== app/Actions/StoreResourceTypeAction.php ===
<?php

namespace App\Actions;

use App\Models\ResourceType;

class StoreResourceTypeAction
{
    public function execute(array $data): ResourceType
    {
        // Если company_id не указан, создаем компанию
        if (!isset($data['company_id']) && isset($data['timetable_id'])) {
            // Получаем company_id из расписания
            $timetable = \App\Models\Timetable::find($data['timetable_id']);
            if ($timetable) {
                $data['company_id'] = $timetable->company_id;
            }
        }

        return ResourceType::create($data);
    }
}



=== app/Actions/RescheduleBookingAction.php ===
<?php

namespace App\Actions;

use App\Models\Booking;
use App\Enums\BookingStatus;
use App\ValueObjects\ResourceConfig;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;

class RescheduleBookingAction
{
    public function execute(
        int $bookingId,
        string $newStart,
        string $newEnd,
        string $requestedBy = 'client'
    ): Booking {
        return DB::transaction(function () use ($bookingId, $newStart, $newEnd, $requestedBy) {
            $booking = Booking::findOrFail($bookingId);
            $resource = $booking->resource;
            $config = $resource->getResourceConfig();

            if (BookingStatus::from($booking->status)->isCancelled()) {
                throw new \Exception('Невозможно перенести отмененную бронь');
            }

            if ($requestedBy === 'client' && !$config->canReschedule($booking->start)) {
                throw new \Exception('Время для переноса брони истекло');
            }

            $newStartTime = Carbon::parse($newStart);
            $newEndTime = Carbon::parse($newEnd);

            $booking->update([
                'start' => $newStartTime,
                'end' => $newEndTime
            ]);

            return $booking;
        });
    }
}



=== app/Actions/GenerateTestDataAction.php ===
<?php

namespace App\Actions;

use App\Models\Company;
use App\Models\Timetable;
use App\Models\ResourceType;
use App\Models\Resource;
use App\Models\Booking;
use App\Services\ArtisanCommandService;
use Carbon\Carbon;

class GenerateTestDataAction
{
    public function __construct(
        private CreateOrUpdateCompanyAction $createOrUpdateCompanyAction,
        private CreateTimetableFromJsonAction $createTimetableFromJsonAction,
        private ArtisanCommandService $artisanCommandService
    ) {}

    public function execute(int $companyId = 1): array
    {
        $company = $this->createOrUpdateCompanyAction->execute($companyId, 'Test Company ' . $companyId);

        // Создаем расписания используя Artisan команды
        $staticTimetable = $this->createStaticTimetable($companyId);
        $dynamicTimetable = $this->createDynamicTimetable($companyId);

        // Анализируем сгенерированные расписания для создания соответствующих ресурсов
        $staticTimetableInfo = $this->artisanCommandService->getTimetableInfo($staticTimetable->schedule, 'static');
        $dynamicTimetableInfo = $this->artisanCommandService->getTimetableInfo($dynamicTimetable->schedule, 'dinamic');

        // Создаем типы ресурсов на основе анализа расписаний
        $resourceTypes = $this->createResourceTypes($companyId, $staticTimetable, $dynamicTimetable, $staticTimetableInfo, $dynamicTimetableInfo);

        // Создаем ресурсы на основе типов
        $resources = $this->createResources($companyId, $resourceTypes, $staticTimetable, $dynamicTimetable);

        // Создаем тестовые бронирования на основе реального расписания
        $bookings = $this->createTestBookings($resources, $staticTimetable, $dynamicTimetable);

        return [
            'company' => $company,
            'timetables' => [
                'static' => $staticTimetable,
                'dynamic' => $dynamicTimetable
            ],
            'timetable_info' => [
                'static' => $staticTimetableInfo,
                'dynamic' => $dynamicTimetableInfo
            ],
            'resource_types' => $resourceTypes,
            'resources' => $resources,
            'bookings' => $bookings,
        ];
    }

    private function createStaticTimetable(int $companyId): Timetable
    {
        // Используем Artisan команду для генерации реального статического расписания
        $staticData = $this->artisanCommandService->generateStaticTimetable($companyId);

        return $this->createTimetableFromJsonAction->execute($companyId, $staticData, 'static');
    }

    private function createDynamicTimetable(int $companyId): Timetable
    {
        // Используем Artisan команду для генерации реального динамического расписания
        $dynamicData = $this->artisanCommandService->generateDynamicTimetable($companyId, 14); // 14 дней для тестов

        return $this->createTimetableFromJsonAction->execute($companyId, $dynamicData, 'dinamic');
    }

    private function createResourceTypes(
        int $companyId,
        Timetable $staticTimetable,
        Timetable $dynamicTimetable,
        array $staticInfo,
        array $dynamicInfo
    ): array {
        // Анализируем расписания для создания соответствующих типов ресурсов

        // Для статического расписания (регулярные рабочие дни)
        $employeeType = ResourceType::create([
            'company_id' => $companyId,
            'timetable_id' => $staticTimetable->id,
            'type' => 'employee',
            'name' => 'Сотрудник',
            'description' => "Персональные консультации ({$staticInfo['working_days']} рабочих дней в неделю)",
            'resource_config' => [
                'slot_duration_minutes' => 60,
                'slot_strategy' => 'fixed',
                'require_confirmation' => false,
                'min_advance_time' => 60,
                'cancellation_time' => 120,
                'reschedule_time' => 240,
            ]
        ]);

        // Для статического расписания (переговорные комнаты)
        $roomType = ResourceType::create([
            'company_id' => $companyId,
            'timetable_id' => $staticTimetable->id,
            'type' => 'meeting_room',
            'name' => 'Переговорная',
            'description' => "Комната для встреч ({$staticInfo['total_breaks']} перерывов в расписании)",
            'resource_config' => [
                'slot_duration_minutes' => 30,
                'slot_strategy' => 'dinamic',
                'require_confirmation' => true,
                'max_participants' => 10,
                'min_advance_time' => 30,
            ]
        ]);

        // Для динамического расписания (специальные мероприятия)
        $trainingType = ResourceType::create([
            'company_id' => $companyId,
            'timetable_id' => $dynamicTimetable->id,
            'type' => 'training',
            'name' => 'Групповая тренировка',
            'description' => "Групповые занятия ({$dynamicInfo['working_days']} дней в расписании)",
            'resource_config' => [
                'slot_duration_minutes' => 90,
                'slot_strategy' => 'fixed',
                'require_confirmation' => false,
                'max_participants' => 20,
                'min_advance_time' => 1440,
            ]
        ]);

        // Дополнительный тип для динамического расписания (специальное оборудование)
        $equipmentType = ResourceType::create([
            'company_id' => $companyId,
            'timetable_id' => $dynamicTimetable->id,
            'type' => 'equipment',
            'name' => 'Специальное оборудование',
            'description' => 'Оборудование для специальных мероприятий',
            'resource_config' => [
                'slot_duration_minutes' => 120,
                'slot_strategy' => 'dinamic',
                'require_confirmation' => true,
                'max_participants' => 5,
                'min_advance_time' => 480,
            ]
        ]);

        return [
            'employee' => $employeeType,
            'meeting_room' => $roomType,
            'training' => $trainingType,
            'equipment' => $equipmentType,
        ];
    }

    private function createResources(
        int $companyId,
        array $resourceTypes,
        Timetable $staticTimetable,
        Timetable $dynamicTimetable
    ): array {
        $resources = [];

        // Ресурсы для статического расписания (сотрудники)
        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['employee']->id,
            'timetable_id' => $staticTimetable->id,
            'options' => ['specialization' => 'Парикмахер', 'experience' => '5 лет'],
            'resource_config' => ['slot_duration_minutes' => 45]
        ]);

        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['employee']->id,
            'timetable_id' => $staticTimetable->id,
            'options' => ['specialization' => 'Массажист', 'experience' => '3 года'],
        ]);

        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['employee']->id,
            'timetable_id' => $staticTimetable->id,
            'options' => ['specialization' => 'Косметолог', 'experience' => '4 года'],
        ]);

        // Ресурсы для статического расписания (переговорные)
        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['meeting_room']->id,
            'timetable_id' => $staticTimetable->id,
            'options' => ['location' => 'Этаж 3', 'capacity' => 8, 'equipment' => ['projector', 'whiteboard']],
            'resource_config' => ['max_participants' => 8]
        ]);

        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['meeting_room']->id,
            'timetable_id' => $staticTimetable->id,
            'options' => ['location' => 'Этаж 2', 'capacity' => 15, 'equipment' => ['tv', 'conference_phone']],
        ]);

        // Ресурсы для динамического расписания (тренировки)
        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['training']->id,
            'timetable_id' => $dynamicTimetable->id,
            'options' => ['location' => 'Зал А', 'trainer' => 'Иван Петров', 'type' => 'Йога'],
        ]);

        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['training']->id,
            'timetable_id' => $dynamicTimetable->id,
            'options' => ['location' => 'Зал Б', 'trainer' => 'Мария Сидорова', 'type' => 'Пилатес'],
        ]);

        // Ресурсы для динамического расписания (оборудование)
        $resources[] = Resource::create([
            'company_id' => $companyId,
            'resource_type_id' => $resourceTypes['equipment']->id,
            'timetable_id' => $dynamicTimetable->id,
            'options' => ['name' => '3D принтер', 'model' => 'Ultimaker S5', 'specifications' => ['print_volume' => '330×240×300 mm']],
        ]);

        return $resources;
    }

    private function createTestBookings(array $resources, Timetable $staticTimetable, Timetable $dynamicTimetable): array
    {
        $bookings = [];
        $now = now();

        // Анализируем расписания для создания реалистичных бронирований
        $staticSchedule = $staticTimetable->schedule;
        $dynamicSchedule = $dynamicTimetable->schedule;

        foreach ($resources as $resource) {
            $isStatic = $resource->timetable_id === $staticTimetable->id;
            $schedule = $isStatic ? $staticSchedule : $dynamicSchedule;

            // Создаем прошедшие бронирования (2-3 на ресурс)
            $pastBookingsCount = rand(2, 3);
            for ($i = 0; $i < $pastBookingsCount; $i++) {
                $daysAgo = rand(1, 7);
                $hour = rand(9, 16);

                $bookings[] = Booking::create([
                    'company_id' => 1,
                    'resource_id' => $resource->id,
                    'timetable_id' => $resource->timetable_id,
                    'start' => $now->copy()->subDays($daysAgo)->setHour($hour)->setMinute(0),
                    'end' => $now->copy()->subDays($daysAgo)->setHour($hour + 1)->setMinute(0),
                    'status' => 'confirmed',
                    'is_group_booking' => $resource->resourceType->type === 'training',
                ]);
            }

            // Создаем будущие бронирования (1-2 на ресурс)
            $futureBookingsCount = rand(1, 2);
            for ($i = 0; $i < $futureBookingsCount; $i++) {
                $daysAhead = rand(1, 14);
                $hour = rand(9, 16);

                $bookings[] = Booking::create([
                    'company_id' => 1,
                    'resource_id' => $resource->id,
                    'timetable_id' => $resource->timetable_id,
                    'start' => $now->copy()->addDays($daysAhead)->setHour($hour)->setMinute(0),
                    'end' => $now->copy()->addDays($daysAhead)->setHour($hour + 1)->setMinute(0),
                    'status' => rand(0, 1) ? 'confirmed' : 'pending',
                    'is_group_booking' => $resource->resourceType->type === 'training',
                ]);
            }
        }

        return $bookings;
    }
}



=== app/Actions/StoreResourceAction.php ===
<?php

namespace App\Actions;

use App\Models\Resource;

class StoreResourceAction
{
    public function execute(array $data): Resource
    {
        // Если company_id не указан, берем из типа ресурса
        if (!isset($data['company_id'])) {
            $resourceType = \App\Models\ResourceType::find($data['resource_type_id']);
            if ($resourceType) {
                $data['company_id'] = $resourceType->company_id;
            }
        }

        return Resource::create($data);
    }
}



=== app/Actions/AttachBookerAction.php ===
<?php

namespace App\Actions;

use App\Models\Booking;
use App\Models\Booker;

class AttachBookerAction
{
    public function execute(Booking $booking, array $bookerData): void
    {
        $booker = Booker::firstOrCreate(
            [
                'external_id' => $bookerData['external_id'] ?? null,
                'type' => $bookerData['type'] ?? 'client'
            ],
            [
                'name' => $bookerData['name'] ?? null,
                'email' => $bookerData['email'] ?? null,
                'phone' => $bookerData['phone'] ?? null,
                'metadata' => $bookerData['metadata'] ?? null,
            ]
        );

        // Прикрепляем booker к бронированию через связь многие-ко-многим
        $booking->bookers()->syncWithoutDetaching([$booker->id]);
    }
}



=== app/Actions/CreateTimetableFromJsonAction.php ===
<?php

namespace App\Actions;

use App\Models\Timetable;
use App\Models\Company;
use App\Enums\TimetableType;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\ValidationException;

class CreateTimetableFromJsonAction
{
    public function execute(int $companyId, array $jsonData, string $type = 'static'): Timetable
    {
        // Очищаем данные от null значений
        $cleanedData = $this->cleanScheduleData($jsonData, $type);

        // Валидация данных
        $this->validateJsonData($cleanedData, $type);

        // Проверяем существование компании
        $company = Company::find($companyId);
        if (!$company) {
            throw new \Exception("Company with ID {$companyId} not found");
        }

        // Создаем расписание
        return Timetable::create([
            'company_id' => $companyId,
            'type' => $type,
            'schedule' => $cleanedData,
        ]);
    }

    private function cleanScheduleData(array $data, string $type): array
    {
        if ($type === TimetableType::STATIC->value) {
            // Удаляем дни с null значениями
            if (isset($data['days']) && is_array($data['days'])) {
                $data['days'] = array_filter($data['days'], function ($day) {
                    return $day !== null;
                });
            }
        } else {
            // Удаляем даты с null значениями
            if (isset($data['dates']) && is_array($data['dates'])) {
                $data['dates'] = array_filter($data['dates'], function ($date) {
                    return $date !== null;
                });
            }
        }

        return $data;
    }

    private function validateJsonData(array $data, string $type): void
    {
        $rules = [];

        if ($type === TimetableType::STATIC->value) {
            $rules = [
                'days' => 'required|array',
                'days.*.working_hours' => 'required|array',
                'days.*.working_hours.start' => 'required|date_format:H:i',
                'days.*.working_hours.end' => 'required|date_format:H:i',
                'days.*.breaks' => 'sometimes|array',
                'days.*.breaks.*.start' => 'required_with:days.*.breaks|date_format:H:i',
                'days.*.breaks.*.end' => 'required_with:days.*.breaks|date_format:H:i',
                'holidays' => 'sometimes|array',
                'holidays.*' => 'string|regex:/^\d{2}-\d{2}$/',
            ];
        } else {
            $rules = [
                'dates' => 'required|array',
                'dates.*.working_hours' => 'required|array',
                'dates.*.working_hours.start' => 'required|date_format:H:i',
                'dates.*.working_hours.end' => 'required|date_format:H:i',
                'dates.*.breaks' => 'sometimes|array',
                'dates.*.breaks.*.start' => 'required_with:dates.*.breaks|date_format:H:i',
                'dates.*.breaks.*.end' => 'required_with:dates.*.breaks|date_format:H:i',
            ];
        }

        $validator = Validator::make($data, $rules);

        if ($validator->fails()) {
            throw new ValidationException($validator);
        }
    }
}



=== app/Actions/CreateOrUpdateCompanyAction.php ===
<?php

namespace App\Actions;

use App\Models\Company;

class CreateOrUpdateCompanyAction
{
    public function execute(int $companyId, ?string $name = null): Company
    {
        $company = Company::find($companyId);

        if (!$company) {
            $company = Company::create([
                'id' => $companyId,
                'name' => $name ?? 'Компания_' . $companyId,
            ]);
        }

        return $company;
    }
}



=== app/Actions/CreateBookingAction.php ===
<?php

namespace App\Actions;

use App\Models\Booking;
use App\Models\Resource;
use App\Enums\BookingStatus;
use App\ValueObjects\ResourceConfig;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;

class CreateBookingAction
{
    public function __construct(
        private \App\Services\Booking\BookingService $bookingService
    ) {}

    public function execute(
        Resource $resource,
        string $start,
        string $end,
        array $bookerData = [],
        bool $isAdmin = false
    ): Booking {
        return DB::transaction(function () use ($resource, $start, $end, $bookerData, $isAdmin) {
            $config = $resource->getResourceConfig();
            $startTime = Carbon::parse($start);
            $endTime = Carbon::parse($end);

            // Используем новый метод для комплексной проверки
            if (!$this->bookingService->isTimeRangeAvailable($resource, $startTime, $endTime)) {
                throw new \Exception('Выбранный временной диапазон недоступен (занят или пересекается с перерывом)');
            }

            $status = $config->requiresConfirmation() && !$isAdmin
                ? BookingStatus::PENDING
                : BookingStatus::CONFIRMED;

            $booking = Booking::create([
                'company_id' => $resource->company_id,
                'resource_id' => $resource->id,
                'timetable_id' => $resource->getEffectiveTimetable()?->id,
                'is_group_booking' => $config->isGroupResource(),
                'start' => $startTime,
                'end' => $endTime,
                'status' => $status->value,
            ]);

            if (!empty($bookerData)) {
                app(AttachBookerAction::class)->execute($booking, $bookerData);
            }

            return $booking;
        });
    }
}



=== app/Enums/SlotStrategy.php ===
<?php

namespace App\Enums;

enum SlotStrategy: string
{
    case FIXED = 'fixed';
    case DINAMIC = 'dinamic';

    public static function values(): array
    {
        return array_column(self::cases(), 'value');
    }

    public static function isValid(string $value): bool
    {
        return in_array($value, self::values());
    }

    public function label(): string
    {
        return match($this) {
            self::FIXED => 'Fixed',
            self::DINAMIC => 'dinamic',
        };
    }
}



=== app/Enums/BookingStatus.php ===
<?php

namespace App\Enums;

enum BookingStatus: string
{
    case PENDING = 'pending';
    case CONFIRMED = 'confirmed';
    case CANCELLED_BY_CLIENT = 'cancelled_by_client';
    case CANCELLED_BY_ADMIN = 'cancelled_by_admin';
    case REJECTED = 'rejected';

    public static function values(): array
    {
        return array_column(self::cases(), 'value');
    }

    public function label(): string
    {
        return match($this) {
            self::PENDING => 'Ожидает подтверждения',
            self::CONFIRMED => 'Подтверждена',
            self::CANCELLED_BY_CLIENT => 'Отменена клиентом',
            self::CANCELLED_BY_ADMIN => 'Отменена администратором',
            self::REJECTED => 'Отклонена',
        };
    }

    public function isActive(): bool
    {
        return in_array($this, [self::PENDING, self::CONFIRMED]);
    }

    public function isCancelled(): bool
    {
        return in_array($this, [self::CANCELLED_BY_CLIENT, self::CANCELLED_BY_ADMIN, self::REJECTED]);
    }
}



=== app/Enums/TimetableType.php ===
<?php

namespace App\Enums;

enum TimetableType: string
{
    case STATIC = 'static';
    case DINAMIC = 'dinamic';

    public static function values(): array
    {
        return array_column(self::cases(), 'value');
    }

    public static function isValid(string $value): bool
    {
        return in_array($value, self::values());
    }

    public function label(): string
    {
        return match($this) {
            self::STATIC => 'Static Schedule',
            self::DINAMIC => 'dinamic Schedule',
        };
    }

    public function isStatic(): bool
    {
        return $this === self::STATIC;
    }

    public function isDinamic(): bool
    {
        return $this === self::DINAMIC;
    }
}



=== app/Models/Concerns/HasResourceConfig.php ===
<?php

namespace App\Models\Concerns;

use App\ValueObjects\ResourceConfig;

trait HasResourceConfig
{
    public function getResourceConfig(): ResourceConfig
    {
        $config = $this->resource_config ?? [];

        if (empty($config) && method_exists($this, 'resourceType')) {
            $config = $this->resourceType->resource_config ?? [];
        }

        return new ResourceConfig($config);
    }

    public function getEffectiveTimetable()
    {
        if ($this->timetable_id) {
            return $this->timetable;
        }

        if (method_exists($this, 'resourceType') && $this->resourceType?->timetable_id) {
            return $this->resourceType->timetable;
        }

        return null;
    }
}



=== app/Models/Timetable.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Timetable extends Model
{
    use HasFactory;

    protected $fillable = [
        'company_id',
        'type',
        'schedule',
    ];

    protected $casts = [
        'schedule' => 'array',
    ];

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function resourceTypes(): HasMany
    {
        return $this->hasMany(ResourceType::class);
    }

    public function resources(): HasMany
    {
        return $this->hasMany(Resource::class);
    }

    public function bookings(): HasMany
    {
        return $this->hasMany(Booking::class);
    }
}



=== app/Models/Booker.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;

class Booker extends Model
{
    use HasFactory;

    protected $fillable = [
        'external_id',
        'type',
        'name',
        'email',
        'phone',
        'metadata'
    ];

    protected $casts = [
        'metadata' => 'array'
    ];

    public function bookings(): BelongsToMany
    {
        return $this->belongsToMany(Booking::class, 'booking_booker')
            ->withTimestamps();
    }
}



=== app/Models/ResourceType.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use App\Models\Concerns\HasResourceConfig;

class ResourceType extends Model
{
    use HasFactory, HasResourceConfig;

    protected $fillable = [
        'company_id',
        'timetable_id',
        'type',
        'name',
        'description',
        'options',
        'resource_config',
    ];

    protected $casts = [
        'options' => 'array',
        'resource_config' => 'array',
    ];

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function timetable(): BelongsTo
    {
        return $this->belongsTo(Timetable::class);
    }

    public function resources(): HasMany
    {
        return $this->hasMany(Resource::class);
    }
}



=== app/Models/Resource.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use App\Models\Concerns\HasResourceConfig;

class Resource extends Model
{
    use HasFactory, HasResourceConfig;

    protected $fillable = [
        'company_id',
        'timetable_id',
        'resource_type_id',
        'options',
        'payload',
        'resource_config',
    ];

    protected $casts = [
        'options' => 'array',
        'payload' => 'array',
        'resource_config' => 'array',
    ];

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function timetable(): BelongsTo
    {
        return $this->belongsTo(Timetable::class);
    }

    public function resourceType(): BelongsTo
    {
        return $this->belongsTo(ResourceType::class);
    }

    public function bookings()
    {
        return $this->hasMany(Booking::class);
    }
}



=== app/Models/Company.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Company extends Model
{
    use HasFactory;

    public $incrementing = false; // Отключаем автоинкремент
    protected $keyType = 'integer'; // Тип ключа

    protected $fillable = ['id', 'name', 'description'];

    public function timetables(): HasMany
    {
        return $this->hasMany(Timetable::class);
    }

    public function resourceTypes(): HasMany
    {
        return $this->hasMany(ResourceType::class);
    }

    public function resources(): HasMany
    {
        return $this->hasMany(Resource::class);
    }

    public function bookings(): HasMany
    {
        return $this->hasMany(Booking::class);
    }
}



=== app/Models/User.php ===
<?php

namespace App\Models;

// use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;

class User extends Authenticatable
{
    use HasApiTokens, HasFactory, Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
        'password' => 'hashed',
    ];
}



=== app/Models/Booking.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;

class Booking extends Model
{
    use HasFactory;

    protected $fillable = [
        'company_id',
        'resource_id',
        'timetable_id',
        'is_group_booking',
        'start',
        'end',
        'status',
        'reason'
    ];

    protected $casts = [
        'is_group_booking' => 'boolean',
        'start' => 'datetime',
        'end' => 'datetime'
    ];

    public function resource(): BelongsTo
    {
        return $this->belongsTo(Resource::class);
    }

    public function timetable(): BelongsTo
    {
        return $this->belongsTo(Timetable::class);
    }

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function bookers(): BelongsToMany
    {
        return $this->belongsToMany(Booker::class, 'booking_booker')
            ->withTimestamps();
    }
}



=== app/Providers/EventServiceProvider.php ===
<?php

namespace App\Providers;

use Illuminate\Auth\Events\Registered;
use Illuminate\Auth\Listeners\SendEmailVerificationNotification;
use Illuminate\Foundation\Support\Providers\EventServiceProvider as ServiceProvider;

class EventServiceProvider extends ServiceProvider
{
    protected $listen = [
        Registered::class => [
            SendEmailVerificationNotification::class,
        ],
        \App\Events\BookingCreated::class => [
            \App\Listeners\BookingCreatedListener::class,
        ],
        \App\Events\BookingConfirmed::class => [
            \App\Listeners\BookingConfirmedListener::class,
        ],
        \App\Events\BookingCancelled::class => [
            \App\Listeners\BookingCancelledListener::class,
        ],
        \App\Events\BookingRescheduled::class => [
            \App\Listeners\BookingRescheduledListener::class,
        ],
        \App\Events\BookingReminder::class => [
            \App\Listeners\BookingReminderListener::class,
        ],
    ];

    public function boot(): void
    {
        parent::boot();
    }
}



=== app/Providers/RouteServiceProvider.php ===
<?php

namespace App\Providers;

use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Foundation\Support\Providers\RouteServiceProvider as ServiceProvider;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;
use Illuminate\Support\Facades\Route;

class RouteServiceProvider extends ServiceProvider
{
    /**
     * The path to your application's "home" route.
     *
     * Typically, users are redirected here after authentication.
     *
     * @var string
     */
    public const HOME = '/home';

    /**
     * Define your route model bindings, pattern filters, and other route configuration.
     */
    public function boot(): void
    {
        RateLimiter::for('api', function (Request $request) {
            return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
        });

        $this->routes(function () {
            Route::middleware('api')
                ->prefix('api')
                ->group(base_path('routes/api.php'));

            Route::middleware('web')
                ->group(base_path('routes/web.php'));
        });
    }
}



=== app/Providers/AppServiceProvider.php ===
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Services\Booking\BookingService;
use App\Services\Booking\SlotGenerationService;
use App\Services\ArtisanCommandService;

class AppServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        $this->app->singleton(SlotGenerationService::class);
        $this->app->singleton(BookingService::class);
        $this->app->singleton(ArtisanCommandService::class);
    }

    public function boot(): void
    {
        //
    }
}



=== app/Providers/AuthServiceProvider.php ===
<?php

namespace App\Providers;

// use Illuminate\Support\Facades\Gate;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * The model to policy mappings for the application.
     *
     * @var array<class-string, class-string>
     */
    protected $policies = [
        //
    ];

    /**
     * Register any authentication / authorization services.
     */
    public function boot(): void
    {
        //
    }
}



=== app/Providers/BroadcastServiceProvider.php ===
<?php

namespace App\Providers;

use Illuminate\Support\Facades\Broadcast;
use Illuminate\Support\ServiceProvider;

class BroadcastServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     */
    public function boot(): void
    {
        Broadcast::routes();

        require base_path('routes/channels.php');
    }
}



=== app/ValueObjects/ResourceConfig.php ===
<?php

namespace App\ValueObjects;

use App\Enums\SlotStrategy;
use InvalidArgumentException;

class ResourceConfig
{
    public ?bool $require_confirmation = false;
    public ?int $slot_duration_minutes = 60;
    public ?int $max_participants = null;
    public ?SlotStrategy $slot_strategy = SlotStrategy::FIXED;
    public ?int $min_advance_time = 0;
    public ?int $cancellation_time = null;
    public ?int $reschedule_time = null;
    public ?int $reminder_time = null;

    public function __construct(array $data = [])
    {
        foreach ($data as $key => $value) {
            if (property_exists($this, $key)) {
                $this->setProperty($key, $value);
            }
        }

        $this->validate();
    }

    private function setProperty(string $key, $value): void
    {
        if ($key === 'slot_strategy') {
            $this->slot_strategy = is_string($value) ? SlotStrategy::from($value) : $value;
        } else {
            $this->$key = $value;
        }
    }

    private function validate(): void
    {
        if ($this->slot_duration_minutes !== null && $this->slot_duration_minutes <= 0) {
            throw new InvalidArgumentException('Slot duration must be positive');
        }

        if ($this->max_participants !== null && $this->max_participants < 0) {
            throw new InvalidArgumentException('Max participants cannot be negative');
        }
    }

    public function toArray(): array
    {
        return [
            'require_confirmation' => $this->require_confirmation,
            'slot_duration_minutes' => $this->slot_duration_minutes,
            'max_participants' => $this->max_participants,
            'slot_strategy' => $this->slot_strategy->value,
            'min_advance_time' => $this->min_advance_time,
            'cancellation_time' => $this->cancellation_time,
            'reschedule_time' => $this->reschedule_time,
            'reminder_time' => $this->reminder_time,
        ];
    }

    public function isGroupResource(): bool
    {
        return $this->max_participants !== null && $this->max_participants > 1;
    }

    public function requiresConfirmation(): bool
    {
        return $this->require_confirmation === true;
    }

    public function isFixedStrategy(): bool
    {
        return $this->slot_strategy === SlotStrategy::FIXED;
    }

    public function isDynamicStrategy(): bool
    {
        return $this->slot_strategy === SlotStrategy::DINAMIC;
    }

    public function canCancel(\DateTime $bookingStart): bool
    {
        if ($this->cancellation_time === null) return true;

        $now = new \DateTime();
        $diff = $now->diff($bookingStart);
        $minutes = $diff->days * 24 * 60 + $diff->h * 60 + $diff->i;

        return $minutes >= $this->cancellation_time;
    }

    public function canReschedule(\DateTime $bookingStart): bool
    {
        if ($this->reschedule_time === null) return true;

        $now = new \DateTime();
        $diff = $now->diff($bookingStart);
        $minutes = $diff->days * 24 * 60 + $diff->h * 60 + $diff->i;

        return $minutes >= $this->reschedule_time;
    }

    public function shouldSendReminder(\DateTime $bookingStart): bool
    {
        if ($this->reminder_time === null) return false;

        $now = new \DateTime();
        $diff = $now->diff($bookingStart);
        $minutes = $diff->days * 24 * 60 + $diff->h * 60 + $diff->i;

        return $minutes <= $this->reminder_time;
    }
}



=== app/Events/BookingCancelled.php ===
<?php

namespace App\Events;

use App\Models\Booking;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class BookingCancelled
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public function __construct(public Booking $booking)
    {
    }
}



=== app/Events/BookingReminder.php ===
<?php

namespace App\Events;

use App\Models\Booking;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class BookingReminder
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public function __construct(public Booking $booking)
    {
    }
}



=== app/Events/BookingCreated.php ===
<?php

namespace App\Events;

use App\Models\Booking;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class BookingCreated
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public function __construct(public Booking $booking)
    {
    }
}



=== app/Events/BookingConfirmed.php ===
<?php

namespace App\Events;

use App\Models\Booking;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class BookingConfirmed
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public function __construct(public Booking $booking)
    {
    }
}



=== app/Events/BookingRescheduled.php ===
<?php

namespace App\Events;

use App\Models\Booking;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class BookingRescheduled
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public function __construct(public Booking $booking)
    {
    }
}



=== app/sh/files.sh ===
#!/bin/bash

# Переходим в корневую директорию проекта
cd "$(dirname "$0")"

# Базовый URL для сырых файлов
BASE_URL="https://raw.githubusercontent.com/tarzanpasha/booking-v2/refs/heads/master"

# Создаем файл с полными URL
find . -type f \
    ! -path "./Vendor/*" \
    ! -path "./vendor/*" \
    ! -path "./Docker/*" \
    ! -path "./docker/*" \
    ! -path "./.git/*" \
    ! -path "./.idea/*" \
    -print0 | while IFS= read -r -d '' file; do
    # Удаляем ./ в начале пути и добавляем URL
    relative_path="${file#./}"
    echo "${BASE_URL}/${relative_path}"
done > project_files.txt

echo "Файл project_files.txt создан"
echo "Найдено файлов: $(wc -l < project_files.txt)"



=== app/Listeners/BookingReminderListener.php ===
<?php

namespace App\Listeners;

use App\Events\BookingReminder;
use App\Services\Logging\BookingLoggerService;

class BookingReminderListener
{
    public function handle(BookingReminder $event)
    {
        BookingLoggerService::info("⏰ [EVENT] Напоминание о брони", [
            'booking_id' => $event->booking->id,
            'start' => $event->booking->start
        ]);
    }
}



=== app/Listeners/BookingCancelledListener.php ===
<?php

namespace App\Listeners;

use App\Events\BookingCancelled;
use App\Services\Logging\BookingLoggerService;

class BookingCancelledListener
{
    public function handle(BookingCancelled $event)
    {
        BookingLoggerService::warning("❌ [EVENT] Бронь отменена", [
            'booking_id' => $event->booking->id,
            'status' => $event->booking->status,
            'reason' => $event->booking->reason
        ]);
    }
}



=== app/Listeners/BookingCreatedListener.php ===
<?php

namespace App\Listeners;

use App\Events\BookingCreated;
use App\Services\Logging\BookingLoggerService;

class BookingCreatedListener
{
    public function handle(BookingCreated $event)
    {
        BookingLoggerService::info("📝 [EVENT] Новая бронь создана", [
            'booking_id' => $event->booking->id,
            'resource_id' => $event->booking->resource_id,
            'status' => $event->booking->status
        ]);
    }
}



=== app/Listeners/BookingRescheduledListener.php ===
<?php

namespace App\Listeners;

use App\Events\BookingRescheduled;
use App\Services\Logging\BookingLoggerService;

class BookingRescheduledListener
{
    public function handle(BookingRescheduled $event)
    {
        BookingLoggerService::info("🔁 [EVENT] Бронь перенесена", [
            'booking_id' => $event->booking->id,
            'new_start' => $event->booking->start,
            'new_end' => $event->booking->end
        ]);
    }
}



=== app/Listeners/BookingConfirmedListener.php ===
<?php

namespace App\Listeners;

use App\Events\BookingConfirmed;
use App\Services\Logging\BookingLoggerService;

class BookingConfirmedListener
{
    public function handle(BookingConfirmed $event)
    {
        BookingLoggerService::info("✅ [EVENT] Бронь подтверждена", [
            'booking_id' => $event->booking->id,
            'status' => $event->booking->status
        ]);
    }
}



=== app/Exceptions/Handler.php ===
<?php

namespace App\Exceptions;

use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Throwable;

class Handler extends ExceptionHandler
{
    /**
     * The list of the inputs that are never flashed to the session on validation exceptions.
     *
     * @var array<int, string>
     */
    protected $dontFlash = [
        'current_password',
        'password',
        'password_confirmation',
    ];

    /**
     * Register the exception handling callbacks for the application.
     */
    public function register(): void
    {
        $this->reportable(function (Throwable $e) {
            //
        });
    }
}



=== app/Services/Booking/SlotGenerationService.php ===
<?php

namespace App\Services\Booking;

use App\Models\Resource;
use App\Models\Booking;
use App\ValueObjects\ResourceConfig;
use Carbon\Carbon;
use Carbon\CarbonPeriod;

class SlotGenerationService
{
    public function getNextAvailableSlots(
        Resource $resource,
        Carbon $from = null,
        int $count = 5,
        bool $onlyToday = true
    ): array {
        $from = $from ?? now();
        $config = $resource->getResourceConfig();
        $slots = [];
        $currentDate = $from->copy();

        while (count($slots) < $count) {
            $daySlots = $this->generateSlotsForDate($resource, $currentDate);

            // Добавляем проверку на пустые слоты и корректную структуру
            if (!empty($daySlots)) {
                foreach ($daySlots as $slot) {
                    if (count($slots) >= $count) break;

                    // Проверяем что слот имеет правильную структуру
                    if (isset($slot['start']) && isset($slot['end'])) {
                        // Проверяем что слот доступен
                        if ($this->isSlotAvailable($resource, $slot['start'], 1)) {
                            $slots[] = $slot;
                        }
                    }
                }
            }

            if ($onlyToday) break;
            $currentDate->addDay();
        }

        return $slots;
    }

    public function generateSlotsForDate(Resource $resource, Carbon $date): array
    {
        $config = $resource->getResourceConfig();
        $timetable = $resource->getEffectiveTimetable();

        if (!$timetable) {
            return [];
        }

        $slots = $config->isFixedStrategy()
            ? $this->generateFixedSlots($resource, $date, $timetable, $config)
            : $this->generateDynamicSlots($resource, $date, $timetable, $config);

        // Гарантируем что все слоты имеют правильную структуру
        return array_filter($slots, function($slot) {
            return isset($slot['start']) && isset($slot['end']) && isset($slot['duration_minutes']);
        });
    }

    private function generateFixedSlots(Resource $resource, Carbon $date, $timetable, ResourceConfig $config): array
    {
        $currentDate = $this->getWorkingHoursForDate($timetable, $date);
        if (!$currentDate || !isset($currentDate['working_hours'])) {
            return [];
        }

        $workingHours = $currentDate['working_hours'];
        $slots = [];
        $slotDuration = $config->slot_duration_minutes ?? 60;

        try {
            $startTime = Carbon::parse($date->format('Y-m-d') . ' ' . $workingHours['start']);
            $endTime = Carbon::parse($date->format('Y-m-d') . ' ' . $workingHours['end']);
        } catch (\Exception $e) {
            return [];
        }

        $breaks = $currentDate['breaks'] ?? [];
        $current = $startTime->copy();

        while ($current->lt($endTime)) {
            $slotEnd = $current->copy()->addMinutes($slotDuration);

            if ($slotEnd->gt($endTime)) break;

            // ИСПРАВЛЕННАЯ ПРОВЕРКА: используем исправленный метод проверки перерывов
            $slotAvailable = true;
            foreach ($breaks as $break) {
                if (!isset($break['start']) || !isset($break['end'])) continue;

                $breakStart = Carbon::parse($date->format('Y-m-d') . ' ' . $break['start']);
                $breakEnd = Carbon::parse($date->format('Y-m-d') . ' ' . $break['end']);

                // Слот не должен пересекаться с перерывом
                if ($current->lt($breakEnd) && $slotEnd->gt($breakStart) &&
                    !$slotEnd->eq($breakStart) && !$current->eq($breakEnd)) {
                    $slotAvailable = false;
                    break;
                }
            }

            if ($slotAvailable) {
                $slots[] = [
                    'start' => $current->copy()->toDateTimeString(),
                    'end' => $slotEnd->copy()->toDateTimeString(),
                    'duration_minutes' => $slotDuration
                ];
            }

            $current->addMinutes($slotDuration);
        }

        return $slots;
    }

    private function generateDynamicSlots(Resource $resource, Carbon $date, $timetable, ResourceConfig $config): array
    {
        $workingHours = $this->getWorkingHoursForDate($timetable, $date);
        if (!$workingHours || !isset($workingHours['working_hours'])) {
            return [];
        }

        $workingHours = $workingHours['working_hours'];

        // Проверяем что working_hours имеет нужные поля
        if (!isset($workingHours['start']) || !isset($workingHours['end'])) {
            return [];
        }

        $bookings = Booking::where('resource_id', $resource->id)
            ->whereDate('start', $date)
            ->whereIn('status', ['pending', 'confirmed'])
            ->orderBy('start')
            ->get();

        $slots = [];
        $slotDuration = $config->slot_duration_minutes ?? 60;

        try {
            $startTime = Carbon::parse($date->format('Y-m-d') . ' ' . $workingHours['start']);
            $endTime = Carbon::parse($date->format('Y-m-d') . ' ' . $workingHours['end']);
        } catch (\Exception $e) {
            return [];
        }

        $breaks = $workingHours['breaks'] ?? [];

        $availablePeriods = $this->getAvailablePeriods($startTime, $endTime, $bookings, $breaks);

        foreach ($availablePeriods as $period) {
            $current = $period['start']->copy();

            while ($current->addMinutes($slotDuration)->lte($period['end'])) {
                $slotStart = $current->copy()->subMinutes($slotDuration);
                $slotEnd = $current->copy();

                $slots[] = [
                    'start' => $slotStart->toDateTimeString(),
                    'end' => $slotEnd->toDateTimeString(),
                    'duration_minutes' => $slotDuration
                ];
            }
        }

        return $slots;
    }

    private function getAvailablePeriods(Carbon $startTime, Carbon $endTime, $bookings, array $breaks): array
    {
        $periods = [['start' => $startTime, 'end' => $endTime]];

        // Обрабатываем бронирования
        foreach ($bookings as $booking) {
            $newPeriods = [];
            foreach ($periods as $period) {
                // Проверяем что период имеет правильную структуру
                if (!isset($period['start']) || !isset($period['end'])) {
                    continue;
                }

                if ($booking->start >= $period['end'] || $booking->end <= $period['start']) {
                    $newPeriods[] = $period;
                } else {
                    if ($booking->start > $period['start']) {
                        $newPeriods[] = ['start' => $period['start'], 'end' => $booking->start];
                    }
                    if ($booking->end < $period['end']) {
                        $newPeriods[] = ['start' => $booking->end, 'end' => $period['end']];
                    }
                }
            }
            $periods = $newPeriods;
        }

        // Обрабатываем перерывы
        foreach ($breaks as $break) {
            // Проверяем что перерыв имеет правильную структуру
            if (!isset($break['start']) || !isset($break['end'])) {
                continue;
            }

            try {
                $breakStart = Carbon::parse($startTime->format('Y-m-d') . ' ' . $break['start']);
                $breakEnd = Carbon::parse($startTime->format('Y-m-d') . ' ' . $break['end']);
            } catch (\Exception $e) {
                continue;
            }

            $newPeriods = [];
            foreach ($periods as $period) {
                if (!isset($period['start']) || !isset($period['end'])) {
                    continue;
                }

                if ($breakStart >= $period['end'] || $breakEnd <= $period['start']) {
                    $newPeriods[] = $period;
                } else {
                    if ($breakStart > $period['start']) {
                        $newPeriods[] = ['start' => $period['start'], 'end' => $breakStart];
                    }
                    if ($breakEnd < $period['end']) {
                        $newPeriods[] = ['start' => $breakEnd, 'end' => $period['end']];
                    }
                }
            }
            $periods = $newPeriods;
        }

        return $periods;
    }

    private function getWorkingHoursForDate($timetable, Carbon $date): ?array
    {
        if (!$timetable || !isset($timetable->schedule)) {
            return null;
        }

        if ($timetable->type === 'static') {
            $dayOfWeek = strtolower($date->englishDayOfWeek);
            return isset($timetable->schedule['days'][$dayOfWeek]) ? $timetable->schedule['days'][$dayOfWeek] : null;
        } else {
            $dateKey = $date->format('m-d');
            return isset($timetable->schedule['dates'][$dateKey]) ? $timetable->schedule['dates'][$dateKey] : null;
        }
    }

    private function isTimeInBreaks(Carbon $start, Carbon $end, array $breaks): bool
    {
        foreach ($breaks as $break) {
            // Проверяем что перерыв имеет правильную структуру
            if (!isset($break['start']) || !isset($break['end'])) {
                continue;
            }

            try {
                $breakStart = Carbon::parse($start->format('Y-m-d') . ' ' . $break['start']);
                $breakEnd = Carbon::parse($start->format('Y-m-d') . ' ' . $break['end']);
            } catch (\Exception $e) {
                continue;
            }

            if ($start < $breakEnd && $end > $breakStart) {
                return true;
            }
        }
        return false;
    }

    private function isSlotAvailable(Resource $resource, string $start, int $slots = 1): bool
    {
        try {
            $startTime = Carbon::parse($start);
        } catch (\Exception $e) {
            return false;
        }

        $config = $resource->getResourceConfig();
        $duration = ($config->slot_duration_minutes ?? 60) * $slots;
        $endTime = $startTime->copy()->addMinutes($duration);

        $overlapExists = Booking::where('resource_id', $resource->id)
            ->where('start', '<', $endTime)
            ->where('end', '>', $startTime)
            ->whereIn('status', ['pending', 'confirmed'])
            ->exists();

        return !$overlapExists;
    }
}



=== app/Services/Booking/BookingService.php ===
<?php

namespace App\Services\Booking;

use App\Models\Booking;
use App\Models\Resource;
use App\Models\Booker;
use App\Enums\BookingStatus;
use App\ValueObjects\ResourceConfig;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;
use App\Services\Logging\BookingLoggerService;

class BookingService
{
    public function __construct(
        private SlotGenerationService $slotService
    ) {}

    /**
     * Проверяет доступность диапазона с учетом перерывов и других бронирований
     */
    public function isTimeRangeAvailable(Resource $resource, Carbon $start, Carbon $end): bool
    {
        // Сначала проверяем бронирования
        if (!$this->isRangeAvailable($resource, $start, $end)) {
            return false;
        }

        // Затем проверяем перерывы с ИСПРАВЛЕННОЙ логикой
        if (!$this->isTimeAvailableConsideringBreaks($resource, $start, $end)) {
            return false;
        }

        return true;
    }

    public function isSlotAvailable(Resource $resource, string $start, int $slots = 1): bool
    {
        $startTime = Carbon::parse($start);
        $config = $resource->getResourceConfig();
        $duration = $config->slot_duration_minutes * $slots;
        $endTime = $startTime->copy()->addMinutes($duration);

        return $this->isRangeAvailable($resource, $startTime, $endTime);
    }

    public function isRangeAvailable(Resource $resource, Carbon $from, Carbon $to): bool
    {
        $overlapExists = Booking::where('resource_id', $resource->id)
            ->where('start', '<', $to)
            ->where('end', '>', $from)
            ->whereIn('status', [BookingStatus::PENDING->value, BookingStatus::CONFIRMED->value])
            ->exists();

        return !$overlapExists;
    }

    public function createBooking(
        Resource $resource,
        string $start,
        string $end,
        array $bookerData = [],
        bool $isAdmin = false
    ): Booking {
        return DB::transaction(function () use ($resource, $start, $end, $bookerData, $isAdmin) {
            $config = $resource->getResourceConfig();
            $startTime = Carbon::parse($start);
            $endTime = Carbon::parse($end);

            if (!$isAdmin) {
                $this->validateBookingTime($resource, $startTime, $endTime, $config);
            }

            // Используем новый метод для комплексной проверки
            if (!$this->isTimeRangeAvailable($resource, $startTime, $endTime)) {
                throw new \Exception('Выбранный временной диапазон недоступен (занят или пересекается с перерывом)');
            }

            $status = $config->requiresConfirmation() && !$isAdmin
                ? BookingStatus::PENDING
                : BookingStatus::CONFIRMED;

            $booking = Booking::create([
                'company_id' => $resource->company_id,
                'resource_id' => $resource->id,
                'timetable_id' => $resource->getEffectiveTimetable()?->id,
                'is_group_booking' => $config->isGroupResource(),
                'start' => $startTime,
                'end' => $endTime,
                'status' => $status->value,
            ]);

            if (!empty($bookerData)) {
                $this->attachBooker($booking, $bookerData);
            }

            BookingLoggerService::info("✅ Бронь создана", [
                'booking_id' => $booking->id,
                'resource_id' => $resource->id,
                'status' => $booking->status,
                'is_admin' => $isAdmin
            ]);

            event(new \App\Events\BookingCreated($booking));

            return $booking;
        });
    }

    public function confirmBooking(int $bookingId): Booking
    {
        $booking = Booking::findOrFail($bookingId);

        if ($booking->status !== BookingStatus::PENDING->value) {
            throw new \Exception('Можно подтверждать только брони в статусе ожидания');
        }

        $booking->status = BookingStatus::CONFIRMED->value;
        $booking->save();

        BookingLoggerService::info("✅ Бронь подтверждена", ['booking_id' => $booking->id]);
        event(new \App\Events\BookingConfirmed($booking));

        return $booking;
    }

    public function cancelBooking(int $bookingId, string $cancelledBy = 'client', ?string $reason = null): Booking
    {
        $booking = Booking::findOrFail($bookingId);
        $config = $booking->resource->getResourceConfig();

        if ($cancelledBy === 'client' && !$config->canCancel($booking->start)) {
            throw new \Exception('Время для отмены брони истекло');
        }

        $status = $cancelledBy === 'admin'
            ? BookingStatus::CANCELLED_BY_ADMIN
            : BookingStatus::CANCELLED_BY_CLIENT;

        $booking->update([
            'status' => $status->value,
            'reason' => $reason
        ]);

        BookingLoggerService::warning("❌ Бронь отменена", [
            'booking_id' => $booking->id,
            'cancelled_by' => $cancelledBy,
            'reason' => $reason
        ]);

        event(new \App\Events\BookingCancelled($booking));

        return $booking;
    }

    public function rescheduleBooking(
        int $bookingId,
        string $newStart,
        string $newEnd,
        string $requestedBy = 'client'
    ): Booking {
        return DB::transaction(function () use ($bookingId, $newStart, $newEnd, $requestedBy) {
            $booking = Booking::findOrFail($bookingId);
            $resource = $booking->resource;
            $config = $resource->getResourceConfig();

            if (BookingStatus::from($booking->status)->isCancelled()) {
                throw new \Exception('Невозможно перенести отмененную бронь');
            }

            if ($requestedBy === 'client' && !$config->canReschedule($booking->start)) {
                throw new \Exception('Время для переноса брони истекло');
            }

            $newStartTime = Carbon::parse($newStart);
            $newEndTime = Carbon::parse($newEnd);

            // Используем новый метод для комплексной проверки нового времени
            if (!$this->isTimeRangeAvailable($resource, $newStartTime, $newEndTime)) {
                throw new \Exception('Новый временной диапазон недоступен (занят или пересекается с перерывом)');
            }

            $booking->update([
                'start' => $newStartTime,
                'end' => $newEndTime
            ]);

            BookingLoggerService::info("🔁 Бронь перенесена", [
                'booking_id' => $booking->id,
                'requested_by' => $requestedBy
            ]);

            event(new \App\Events\BookingRescheduled($booking));

            return $booking;
        });
    }

    public function getBookingsForResourceInRange(Resource $resource, string $from, string $to)
    {
        return Booking::where('resource_id', $resource->id)
            ->where('start', '<', $to)
            ->where('end', '>', $from)
            ->whereIn('status', [BookingStatus::PENDING->value, BookingStatus::CONFIRMED->value])
            ->get();
    }

    public function getNextAvailableSlots(
        Resource $resource,
        Carbon $from = null,
        int $count = 5,
        bool $onlyToday = true
    ): array {
        return $this->slotService->getNextAvailableSlots($resource, $from, $count, $onlyToday);
    }

    private function validateBookingTime(Resource $resource, Carbon $start, Carbon $end, ResourceConfig $config): void
    {
        $now = now();

        if ($start->diffInMinutes($now) < $config->min_advance_time) {
            throw new \Exception('Бронирование возможно только за ' . $config->min_advance_time . ' минут');
        }

        if (!$this->isValidSlotTime($resource, $start, $end, $config)) {
            throw new \Exception('Выбранное время не соответствует доступным слотам');
        }
    }

    private function isValidSlotTime(Resource $resource, Carbon $start, Carbon $end, ResourceConfig $config): bool
    {
        if ($config->isFixedStrategy()) {
            $slots = $this->slotService->generateSlotsForDate($resource, $start);

            foreach ($slots as $slot) {
                if ($slot['start'] === $start->toDateTimeString() && $slot['end'] === $end->toDateTimeString()) {
                    return true;
                }
            }
            return false;
        }

        return true;
    }

    private function attachBooker(Booking $booking, array $bookerData): void
    {
        $booker = Booker::firstOrCreate(
            [
                'external_id' => $bookerData['external_id'] ?? null,
                'type' => $bookerData['type'] ?? 'client'
            ],
            [
                'name' => $bookerData['name'] ?? null,
                'email' => $bookerData['email'] ?? null,
                'phone' => $bookerData['phone'] ?? null,
                'metadata' => $bookerData['metadata'] ?? null,
            ]
        );

        $booking->bookers()->syncWithoutDetaching([$booker->id]);
    }

    /**
     * Проверяет доступность времени с учетом перерывов
     */
    public function isTimeAvailableConsideringBreaks(Resource $resource, Carbon $start, Carbon $end): bool
    {
        $timetable = $resource->getEffectiveTimetable();

        if (!$timetable) {
            return true; // Если нет расписания, считаем что перерывов нет
        }

        $workingHours = $this->getWorkingHoursForDate($timetable, $start);

        if (!$workingHours) {
            return true; // Если нет рабочих часов на эту дату
        }

        $breaks = $workingHours['breaks'] ?? [];

        foreach ($breaks as $break) {
            if (!isset($break['start']) || !isset($break['end'])) {
                continue;
            }

            try {
                $breakStart = Carbon::parse($start->format('Y-m-d') . ' ' . $break['start']);
                $breakEnd = Carbon::parse($start->format('Y-m-d') . ' ' . $break['end']);
            } catch (\Exception $e) {
                continue;
            }

            // ИСПРАВЛЕННАЯ ЛОГИКА ПРОВЕРКИ ПЕРЕСЕЧЕНИЙ:
            // Пересечение есть только если время бронирования ПЕРЕСЕКАЕТ перерыв
            // Не считается пересечением:
            // - бронь заканчивается точно в начале перерыва ($end == $breakStart)
            // - бронь начинается точно в конце перерыва ($start == $breakEnd)

            $startInBreak = $start->between($breakStart, $breakEnd, false); // false = исключая границы
            $endInBreak = $end->between($breakStart, $breakEnd, false);
            $containsBreak = $start->lt($breakStart) && $end->gt($breakEnd);
            $containedByBreak = $start->gt($breakStart) && $end->lt($breakEnd);

            // Дополнительные проверки для пограничных случаев
            $touchesBreakStart = $end->eq($breakStart); // заканчивается точно в начале перерыва
            $touchesBreakEnd = $start->eq($breakEnd);   // начинается точно в конце перерыва

            // Пересечение есть если:
            // - начало ИЛИ конец брони внутри перерыва (исключая границы)
            // - бронь полностью содержит перерыв
            // - перерыв полностью содержит бронь
            if (($startInBreak && !$start->eq($breakEnd)) ||
                ($endInBreak && !$end->eq($breakStart)) ||
                $containsBreak ||
                $containedByBreak) {
                return false;
            }

            // Дополнительная проверка: если бронь начинается ДО перерыва и заканчивается ПОСЛЕ перерыва
            // но не полностью содержит его (граничные случаи)
            if ($start->lt($breakStart) && $end->gt($breakEnd)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Получает рабочие часы для даты
     */
    private function getWorkingHoursForDate($timetable, Carbon $date): ?array
    {
        if (!$timetable || !isset($timetable->schedule)) {
            return null;
        }

        if ($timetable->type === 'static') {
            $dayOfWeek = strtolower($date->englishDayOfWeek);
            return isset($timetable->schedule['days'][$dayOfWeek]) ? $timetable->schedule['days'][$dayOfWeek] : null;
        } else {
            $dateKey = $date->format('m-d');
            return isset($timetable->schedule['dates'][$dateKey]) ? $timetable->schedule['dates'][$dateKey] : null;
        }
    }
}



=== app/Services/ArtisanCommandService.php ===
<?php

namespace App\Services;

use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Cache;

class ArtisanCommandService
{
    /**
     * Выполняет команду генерации статического расписания и возвращает данные
     */
    public function generateStaticTimetable(int $companyId): array
    {
        // Выполняем команду
        Artisan::call('timetable:generate-static', [
            'company_id' => $companyId
        ]);

        // Получаем сгенерированные данные из файла
        $filePath = storage_path('app/exports/static_timetable_example.json');
        if (!file_exists($filePath)) {
            throw new \Exception('Static timetable example file not found');
        }

        $content = file_get_contents($filePath);
        return json_decode($content, true);
    }

    /**
     * Выполняет команду генерации динамического расписания и возвращает данные
     */
    public function generateDynamicTimetable(int $companyId, int $days = 30): array
    {
        // Выполняем команду
        Artisan::call('timetable:generate-dinamic', [
            'company_id' => $companyId,
            'days' => $days
        ]);

        // Получаем сгенерированные данные из файла
        $filePath = storage_path('app/exports/dinamic_timetable_example.json');
        if (!file_exists($filePath)) {
            throw new \Exception('Dynamic timetable example file not found');
        }

        $content = file_get_contents($filePath);
        return json_decode($content, true);
    }

    /**
     * Получает информацию о сгенерированном расписании
     */
    public function getTimetableInfo(array $timetableData, string $type): array
    {
        if ($type === 'static') {
            $workingDays = count($timetableData['days'] ?? []);
            $totalBreaks = 0;

            foreach ($timetableData['days'] ?? [] as $day) {
                $totalBreaks += count($day['breaks'] ?? []);
            }

            return [
                'working_days' => $workingDays,
                'total_breaks' => $totalBreaks,
                'holidays' => count($timetableData['holidays'] ?? [])
            ];
        } else {
            $workingDays = count($timetableData['dates'] ?? []);
            $totalBreaks = 0;

            foreach ($timetableData['dates'] ?? [] as $date) {
                $totalBreaks += count($date['breaks'] ?? []);
            }

            return [
                'working_days' => $workingDays,
                'total_breaks' => $totalBreaks,
                'schedule_types' => array_unique(array_column($timetableData['dates'] ?? [], 'schedule_type'))
            ];
        }
    }
}



=== app/Services/Logging/BookingLoggerService.php ===
<?php

namespace App\Services\Logging;

use Illuminate\Support\Facades\Log;

class BookingLoggerService
{
    public static function info(string $message, array $context = []): void
    {
        Log::channel('booking')->info($message, $context);
    }

    public static function warning(string $message, array $context = []): void
    {
        Log::channel('booking')->warning($message, $context);
    }

    public static function error(string $message, array $context = []): void
    {
        Log::channel('booking')->error($message, $context);
    }

    public static function debug(string $message, array $context = []): void
    {
        Log::channel('booking')->debug($message, $context);
    }
}



=== database/factories/UserFactory.php ===
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\User>
 */
class UserFactory extends Factory
{
    /**
     * The current password being used by the factory.
     */
    protected static ?string $password;

    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            'name' => fake()->name(),
            'email' => fake()->unique()->safeEmail(),
            'email_verified_at' => now(),
            'password' => static::$password ??= Hash::make('password'),
            'remember_token' => Str::random(10),
        ];
    }

    /**
     * Indicate that the model's email address should be unverified.
     */
    public function unverified(): static
    {
        return $this->state(fn (array $attributes) => [
            'email_verified_at' => null,
        ]);
    }
}



=== database/migrations/2025_01_15_000003_create_resource_types_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('resource_types', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('company_id');
            $table->unsignedBigInteger('timetable_id')->nullable();
            $table->string('type', 63);
            $table->string('name', 127);
            $table->string('description', 255)->nullable();
            $table->json('options')->nullable();
            $table->json('resource_config')->nullable();
            $table->timestamps();
            $table->unique(['company_id', 'type']);

            $table->foreign('company_id')->references('id')->on('companies')->cascadeOnDelete();
            $table->foreign('timetable_id')->references('id')->on('timetables')->nullOnDelete();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('resource_types');
    }
};



=== database/migrations/2014_10_12_000000_create_users_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('users');
    }
};



=== database/migrations/2025_01_15_000004_create_resources_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('resources', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('company_id');
            $table->unsignedBigInteger('timetable_id')->nullable();
            $table->foreignId('resource_type_id')->constrained('resource_types')->cascadeOnDelete();
            $table->json('options')->nullable();
            $table->json('payload')->nullable();
            $table->json('resource_config')->nullable();
            $table->timestamps();

            $table->foreign('company_id')->references('id')->on('companies')->cascadeOnDelete();
            $table->foreign('timetable_id')->references('id')->on('timetables')->nullOnDelete();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('resources');
    }
};



=== database/migrations/2025_01_15_100000_create_booking_tables.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        // Таблица бронирований
        Schema::create('bookings', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('company_id');
            $table->foreignId('resource_id')->constrained('resources')->cascadeOnDelete();
            $table->foreignId('timetable_id')->nullable()->constrained('timetables')->nullOnDelete();
            $table->boolean('is_group_booking')->default(false);
            $table->dateTime('start');
            $table->dateTime('end');
            $table->string('status')->default('pending');
            $table->string('reason', 255)->nullable();
            $table->timestamps();

            $table->foreign('company_id')->references('id')->on('companies')->cascadeOnDelete();
            $table->index(['resource_id', 'start', 'end']);
            $table->index(['company_id', 'start']);
        });

        // Таблица бронирующих (клиентов/администраторов)
        Schema::create('bookers', function (Blueprint $table) {
            $table->id();
            $table->string('external_id')->nullable();
            $table->string('type');
            $table->string('name')->nullable();
            $table->string('email')->nullable();
            $table->string('phone')->nullable();
            $table->json('metadata')->nullable();
            $table->timestamps();

            $table->index(['external_id', 'type']);
        });

        // Связующая таблица между бронированиями и бронирующими
        Schema::create('booking_booker', function (Blueprint $table) {
            $table->id();
            $table->foreignId('booking_id')->constrained()->cascadeOnDelete();
            $table->foreignId('booker_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['booking_id', 'booker_id']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('booking_booker');
        Schema::dropIfExists('bookers');
        Schema::dropIfExists('bookings');
    }
};



=== database/migrations/2025_01_15_000001_create_companies_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('companies', function (Blueprint $table) {
            $table->unsignedBigInteger('id')->primary();
            $table->string('name')->nullable();
            $table->text('description')->nullable();
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('companies');
    }
};



=== database/migrations/2014_10_12_100000_create_password_reset_tokens_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('password_reset_tokens', function (Blueprint $table) {
            $table->string('email')->primary();
            $table->string('token');
            $table->timestamp('created_at')->nullable();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('password_reset_tokens');
    }
};



=== database/migrations/2019_12_14_000001_create_personal_access_tokens_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('personal_access_tokens', function (Blueprint $table) {
            $table->id();
            $table->morphs('tokenable');
            $table->string('name');
            $table->string('token', 64)->unique();
            $table->text('abilities')->nullable();
            $table->timestamp('last_used_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('personal_access_tokens');
    }
};



=== database/migrations/2019_08_19_000000_create_failed_jobs_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('failed_jobs', function (Blueprint $table) {
            $table->id();
            $table->string('uuid')->unique();
            $table->text('connection');
            $table->text('queue');
            $table->longText('payload');
            $table->longText('exception');
            $table->timestamp('failed_at')->useCurrent();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('failed_jobs');
    }
};



=== database/migrations/2025_01_15_000002_create_timetables_table.php ===
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('timetables', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('company_id');
            $table->string('type', 32)->default('static');
            $table->json('schedule')->nullable();
            $table->timestamps();

            $table->foreign('company_id')->references('id')->on('companies')->cascadeOnDelete();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('timetables');
    }
};



=== database/seeders/DatabaseSeeder.php ===
<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        // \App\Models\User::factory(10)->create();

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}



=== database/.gitignore ===
*.sqlite*



=== routes/api.php ===
<?php

use Illuminate\Support\Facades\Route;

// =============================================
// Booking System Routes - Core Entities
// =============================================

use App\Http\Controllers\CompanyController;
use App\Http\Controllers\TimetableController;
use App\Http\Controllers\ResourceTypeController;
use App\Http\Controllers\ResourceController;
use App\Http\Controllers\Api\BookingController;
use App\Http\Controllers\Api\TimetableImportController;

// Core Entities CRUD
Route::apiResource('companies', CompanyController::class);
Route::apiResource('timetables', TimetableController::class);
Route::apiResource('resource-types', ResourceTypeController::class);
Route::apiResource('resources', ResourceController::class);

// Additional timetable routes
Route::prefix('timetables/{timetable}')->group(function () {
    Route::post('/attach-resource', [TimetableController::class, 'attachResource']);
    Route::post('/detach-resource', [TimetableController::class, 'detachResource']);
    Route::post('/attach-resource-type', [TimetableController::class, 'attachResourceType']);
    Route::post('/detach-resource-type', [TimetableController::class, 'detachResourceType']);
});

// =============================================
// Booking System Routes - Booking Functionality
// =============================================

Route::prefix('booking')->group(function () {
    Route::get('/resources', [BookingController::class, 'getResources']);
    Route::get('/{resource}/slots', [BookingController::class, 'getAvailableSlots']);
    Route::post('/create', [BookingController::class, 'createBooking']);
    Route::post('/{id}/confirm', [BookingController::class, 'confirmBooking']);
    Route::post('/{id}/cancel', [BookingController::class, 'cancelBooking']);
    Route::post('/{id}/reschedule', [BookingController::class, 'rescheduleBooking']);
    Route::get('/resource/{id}/bookings', [BookingController::class, 'getBookingsForResource']);
    Route::get('/check', [BookingController::class, 'checkSlotAvailability']);
});

// =============================================
// Timetable Import Routes
// =============================================

Route::prefix('timetables')->group(function () {
    Route::post('/import-json', [TimetableImportController::class, 'importFromJson']);
    Route::post('/import-file', [TimetableImportController::class, 'importFromFile']);
});




=== routes/console.php ===
<?php

use Illuminate\Foundation\Inspiring;
use Illuminate\Support\Facades\Artisan;

/*
|--------------------------------------------------------------------------
| Console Routes
|--------------------------------------------------------------------------
|
| This file is where you may define all of your Closure based console
| commands. Each Closure is bound to a command instance allowing a
| simple approach to interacting with each command's IO methods.
|
*/

Artisan::command('inspire', function () {
    $this->comment(Inspiring::quote());
})->purpose('Display an inspiring quote');



=== routes/web.php ===
<?php

use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| Web Routes
|--------------------------------------------------------------------------
|
| Here is where you can register web routes for your application. These
| routes are loaded by the RouteServiceProvider and all of them will
| be assigned to the "web" middleware group. Make something great!
|
*/

Route::get('/', function () {
    return view('welcome');
});



=== routes/channels.php ===
<?php

use Illuminate\Support\Facades\Broadcast;

/*
|--------------------------------------------------------------------------
| Broadcast Channels
|--------------------------------------------------------------------------
|
| Here you may register all of the event broadcasting channels that your
| application supports. The given channel authorization callbacks are
| used to check if an authenticated user can listen to the channel.
|
*/

Broadcast::channel('App.Models.User.{id}', function ($user, $id) {
    return (int) $user->id === (int) $id;
});



